{"ast":null,"code":"/**\n * @import {\n *   Construct,\n *   Event,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\nimport { ok as assert } from 'devlop';\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { resolveAll } from 'micromark-util-resolve-all';\nimport { codes, constants, types } from 'micromark-util-symbol';\n/** @type {Construct} */\n\nexport const labelEnd = {\n  name: 'labelEnd',\n  resolveAll: resolveAllLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  tokenize: tokenizeLabelEnd\n};\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\n\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n};\n/** @type {Construct} */\n\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n};\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  /** @type {Array<Event>} */\n\n  const newEvents = [];\n\n  while (++index < events.length) {\n    const token = events[index][1];\n    newEvents.push(events[index]);\n\n    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {\n      // Remove the marker.\n      const offset = token.type === types.labelImage ? 4 : 2;\n      token.type = types.data;\n      index += offset;\n    }\n  } // If the events are equal, we don't have to copy newEvents to events\n\n\n  if (events.length !== newEvents.length) {\n    splice(events, 0, events.length, newEvents);\n  }\n\n  return events;\n}\n/** @type {Resolver} */\n\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n\n  let token;\n  /** @type {number | undefined} */\n\n  let open;\n  /** @type {number | undefined} */\n\n  let close;\n  /** @type {Array<Event>} */\n\n  let media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (token.type === types.link || token.type === types.labelLink && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {\n        open = index;\n\n        if (token.type !== types.labelLink) {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index;\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found');\n  assert(close !== undefined, '`close` is supposed to be found');\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: { ...events[open][1].start\n    },\n    end: { ...events[events.length - 1][1].end\n    }\n  };\n  const label = {\n    type: types.label,\n    start: { ...events[open][1].start\n    },\n    end: { ...events[close][1].end\n    }\n  };\n  const text = {\n    type: types.labelText,\n    start: { ...events[open + offset + 2][1].end\n    },\n    end: { ...events[close - 2][1].start\n    }\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  media = push(media, [['enter', text, context]]); // Always populated by defaults.\n\n  assert(context.parser.constructs.insideSpan.null, 'expected `insideSpan.null` to be populated'); // Between.\n\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)); // Media close.\n\n  media = push(media, [['exit', group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n\n  let labelStart;\n  /** @type {boolean} */\n\n  let defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === types.labelImage || self.events[index][1].type === types.labelLink) && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`'); // If there is not an okay opening.\n\n    if (!labelStart) {\n      return nok(code);\n    } // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n\n\n    if (labelStart._inactive) {\n      return labelEndNok(code);\n    }\n\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter(types.labelEnd);\n    effects.enter(types.labelMarker);\n    effects.consume(code);\n    effects.exit(types.labelMarker);\n    effects.exit(types.labelEnd);\n    return after;\n  }\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n    // Resource (`[asd](fgh)`)?\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);\n    } // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n\n\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);\n    } // Shortcut (`[asd]`) reference?\n\n\n    return defined ? labelEndOk(code) : labelEndNok(code);\n  }\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function referenceNotFull(code) {\n    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);\n  }\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code);\n  }\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function labelEndNok(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart;\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function resourceStart(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren');\n    effects.enter(types.resource);\n    effects.enter(types.resourceMarker);\n    effects.consume(code);\n    effects.exit(types.resourceMarker);\n    return resourceBefore;\n  }\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);\n  }\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceOpen(code) {\n    if (code === codes.rightParenthesis) {\n      return resourceEnd(code);\n    }\n\n    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, types.resourceDestination, types.resourceDestinationLiteral, types.resourceDestinationLiteralMarker, types.resourceDestinationRaw, types.resourceDestinationString, constants.linkResourceDestinationBalanceMax)(code);\n  }\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);\n  }\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceDestinationMissing(code) {\n    return nok(code);\n  }\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceBetween(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      return factoryTitle(effects, resourceTitleAfter, nok, types.resourceTitle, types.resourceTitleMarker, types.resourceTitleString)(code);\n    }\n\n    return resourceEnd(code);\n  }\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);\n  }\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceEnd(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker);\n      effects.consume(code);\n      effects.exit(types.resourceMarker);\n      effects.exit(types.resource);\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this;\n  return referenceFull;\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function referenceFull(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket');\n    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, types.reference, types.referenceMarker, types.referenceString)(code);\n  }\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function referenceFullMissing(code) {\n    return nok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart;\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n    assert(code === codes.leftSquareBracket, 'expected left bracket');\n    effects.enter(types.reference);\n    effects.enter(types.referenceMarker);\n    effects.consume(code);\n    effects.exit(types.referenceMarker);\n    return referenceCollapsedOpen;\n  }\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n\n\n  function referenceCollapsedOpen(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker);\n      effects.consume(code);\n      effects.exit(types.referenceMarker);\n      effects.exit(types.reference);\n      return ok;\n    }\n\n    return nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factoryDestination","factoryLabel","factoryTitle","factoryWhitespace","markdownLineEndingOrSpace","push","splice","normalizeIdentifier","resolveAll","codes","constants","types","labelEnd","name","resolveAllLabelEnd","resolveTo","resolveToLabelEnd","tokenize","tokenizeLabelEnd","resourceConstruct","tokenizeResource","referenceFullConstruct","tokenizeReferenceFull","referenceCollapsedConstruct","tokenizeReferenceCollapsed","events","index","newEvents","length","token","type","labelImage","labelLink","offset","data","context","open","close","media","link","_inactive","_balanced","undefined","group","image","start","end","label","text","labelText","slice","parser","constructs","insideSpan","null","effects","nok","self","labelStart","defined","code","rightSquareBracket","labelEndNok","includes","sliceSerialize","now","enter","labelMarker","consume","exit","after","leftParenthesis","attempt","labelEndOk","leftSquareBracket","referenceNotFull","resourceStart","resource","resourceMarker","resourceBefore","resourceOpen","rightParenthesis","resourceEnd","resourceDestinationAfter","resourceDestinationMissing","resourceDestination","resourceDestinationLiteral","resourceDestinationLiteralMarker","resourceDestinationRaw","resourceDestinationString","linkResourceDestinationBalanceMax","resourceBetween","quotationMark","apostrophe","resourceTitleAfter","resourceTitle","resourceTitleMarker","resourceTitleString","referenceFull","call","referenceFullAfter","referenceFullMissing","reference","referenceMarker","referenceString","referenceCollapsedStart","referenceCollapsedOpen"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark-core-commonmark/dev/lib/label-end.js"],"sourcesContent":["/**\n * @import {\n *   Construct,\n *   Event,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  resolveAll: resolveAllLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  tokenize: tokenizeLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {tokenize: tokenizeResource}\n/** @type {Construct} */\nconst referenceFullConstruct = {tokenize: tokenizeReferenceFull}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {tokenize: tokenizeReferenceCollapsed}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Array<Event>} */\n  const newEvents = []\n  while (++index < events.length) {\n    const token = events[index][1]\n    newEvents.push(events[index])\n\n    if (\n      token.type === types.labelImage ||\n      token.type === types.labelLink ||\n      token.type === types.labelEnd\n    ) {\n      // Remove the marker.\n      const offset = token.type === types.labelImage ? 4 : 2\n      token.type = types.data\n      index += offset\n    }\n  }\n\n  // If the events are equal, we don't have to copy newEvents to events\n  if (events.length !== newEvents.length) {\n    splice(events, 0, events.length, newEvents)\n  }\n\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (\n        token.type === types.link ||\n        (token.type === types.labelLink && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === types.labelImage || token.type === types.labelLink) &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== types.labelLink) {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found')\n  assert(close !== undefined, '`close` is supposed to be found')\n\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: {...events[open][1].start},\n    end: {...events[events.length - 1][1].end}\n  }\n\n  const label = {\n    type: types.label,\n    start: {...events[open][1].start},\n    end: {...events[close][1].end}\n  }\n\n  const text = {\n    type: types.labelText,\n    start: {...events[open + offset + 2][1].end},\n    end: {...events[close - 2][1].start}\n  }\n\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n  assert(\n    context.parser.constructs.insideSpan.null,\n    'expected `insideSpan.null` to be populated'\n  )\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n\n  splice(events, open, events.length, media)\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === types.labelImage ||\n        self.events[index][1].type === types.labelLink) &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({start: labelStart.end, end: self.now()})\n      )\n    )\n    effects.enter(types.labelEnd)\n    effects.enter(types.labelMarker)\n    effects.consume(code)\n    effects.exit(types.labelMarker)\n    effects.exit(types.labelEnd)\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren')\n    effects.enter(types.resource)\n    effects.enter(types.resourceMarker)\n    effects.consume(code)\n    effects.exit(types.resourceMarker)\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === codes.rightParenthesis) {\n      return resourceEnd(code)\n    }\n\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      types.resourceDestination,\n      types.resourceDestinationLiteral,\n      types.resourceDestinationLiteralMarker,\n      types.resourceDestinationRaw,\n      types.resourceDestinationString,\n      constants.linkResourceDestinationBalanceMax\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        types.resourceTitle,\n        types.resourceTitleMarker,\n        types.resourceTitleString\n      )(code)\n    }\n\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker)\n      effects.consume(code)\n      effects.exit(types.resourceMarker)\n      effects.exit(types.resource)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      types.reference,\n      types.referenceMarker,\n      types.referenceString\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    effects.enter(types.reference)\n    effects.enter(types.referenceMarker)\n    effects.consume(code)\n    effects.exit(types.referenceMarker)\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker)\n      effects.consume(code)\n      effects.exit(types.referenceMarker)\n      effects.exit(types.reference)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"],"mappings":"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B;IACAL,OAAO,CAACc,IAAR,CAAa1D,KAAK,CAACwD,WAAnB;IACAZ,OAAO,CAACc,IAAR,CAAa1D,KAAK,CAACC,QAAnB;IACA,OAAO0D,KAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE,SAASA,KAAT,CAAeV,IAAf,EAAqB;IACnB;IACA;IAEA;IACA,IAAIA,IAAI,KAAKnD,KAAK,CAAC8D,eAAnB,EAAoC;MAClC,OAAOhB,OAAO,CAACiB,OAAR,CACLrD,iBADK,EAELsD,UAFK,EAGLd,OAAO,GAAGc,UAAH,GAAgBX,WAHlB,EAILF,IAJK,CAAP;IAKD,CAXkB,CAanB;;;IACA,IAAIA,IAAI,KAAKnD,KAAK,CAACiE,iBAAnB,EAAsC;MACpC,OAAOnB,OAAO,CAACiB,OAAR,CACLnD,sBADK,EAELoD,UAFK,EAGLd,OAAO,GAAGgB,gBAAH,GAAsBb,WAHxB,EAILF,IAJK,CAAP;IAKD,CApBkB,CAsBnB;;;IACA,OAAOD,OAAO,GAAGc,UAAU,CAACb,IAAD,CAAb,GAAsBE,WAAW,CAACF,IAAD,CAA/C;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE,SAASe,gBAAT,CAA0Bf,IAA1B,EAAgC;IAC9B,OAAOL,OAAO,CAACiB,OAAR,CACLjD,2BADK,EAELkD,UAFK,EAGLX,WAHK,EAILF,IAJK,CAAP;EAKD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE,SAASa,UAAT,CAAoBb,IAApB,EAA0B;IACxB;IACA,OAAO9D,EAAE,CAAC8D,IAAD,CAAT;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE,SAASE,WAAT,CAAqBF,IAArB,EAA2B;IACzBF,UAAU,CAACjB,SAAX,GAAuB,IAAvB;IACA,OAAOe,GAAG,C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"},"metadata":{},"sourceType":"module"}