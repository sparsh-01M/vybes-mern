{"ast":null,"code":"import { invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\n\nconst percentToProgress = percent => percent / 100;\n\nclass JSAnimation extends WithPromise {\n  constructor(options) {\n    super();\n    this.state = \"idle\";\n    this.startTime = null;\n    this.isStopped = false;\n    /**\n     * The current time of the animation.\n     */\n\n    this.currentTime = 0;\n    /**\n     * The time at which the animation was paused.\n     */\n\n    this.holdTime = null;\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n\n    this.playbackSpeed = 1;\n    /**\n     * This method is bound to the instance to fix a pattern where\n     * animation.stop is returned as a reference from a useEffect.\n     */\n\n    this.stop = () => {\n      const {\n        motionValue\n      } = this.options;\n\n      if (motionValue && motionValue.updatedAt !== time.now()) {\n        this.tick(time.now());\n      }\n\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      this.teardown();\n      const {\n        onStop\n      } = this.options;\n      onStop && onStop();\n    };\n\n    activeAnimations.mainThread++;\n    this.options = options;\n    this.initAnimation();\n    this.play();\n    if (options.autoplay === false) this.pause();\n  }\n\n  initAnimation() {\n    const {\n      options\n    } = this;\n    replaceTransitionType(options);\n    const {\n      type = keyframes,\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType,\n      velocity = 0\n    } = options;\n    let {\n      keyframes: keyframes$1\n    } = options;\n    const generatorFactory = type || keyframes;\n\n    if (process.env.NODE_ENV !== \"production\" && generatorFactory !== keyframes) {\n      invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n    }\n\n    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n      this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n      keyframes$1 = [0, 100];\n    }\n\n    const generator = generatorFactory({ ...options,\n      keyframes: keyframes$1\n    });\n    /**\n     * If we have a mirror repeat type we need to create a second generator that outputs the\n     * mirrored (not reversed) animation and later ping pong between the two generators.\n     */\n\n    if (repeatType === \"mirror\") {\n      this.mirroredGenerator = generatorFactory({ ...options,\n        keyframes: [...keyframes$1].reverse(),\n        velocity: -velocity\n      });\n    }\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n\n\n    if (generator.calculatedDuration === null) {\n      generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n\n    const {\n      calculatedDuration\n    } = generator;\n    this.calculatedDuration = calculatedDuration;\n    this.resolvedDuration = calculatedDuration + repeatDelay;\n    this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n    this.generator = generator;\n  }\n\n  updateTime(timestamp) {\n    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed; // Update currentTime\n\n    if (this.holdTime !== null) {\n      this.currentTime = this.holdTime;\n    } else {\n      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n      // example.\n      this.currentTime = animationTime;\n    }\n  }\n\n  tick(timestamp) {\n    let sample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      generator,\n      totalDuration,\n      mixKeyframes,\n      mirroredGenerator,\n      resolvedDuration,\n      calculatedDuration\n    } = this;\n    if (this.startTime === null) return generator.next(0);\n    const {\n      delay = 0,\n      keyframes,\n      repeat,\n      repeatType,\n      repeatDelay,\n      type,\n      onUpdate,\n      finalKeyframe\n    } = this.options;\n    /**\n     * requestAnimationFrame timestamps can come through as lower than\n     * the startTime as set by performance.now(). Here we prevent this,\n     * though in the future it could be possible to make setting startTime\n     * a pending operation that gets resolved here.\n     */\n\n    if (this.speed > 0) {\n      this.startTime = Math.min(this.startTime, timestamp);\n    } else if (this.speed < 0) {\n      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n    }\n\n    if (sample) {\n      this.currentTime = timestamp;\n    } else {\n      this.updateTime(timestamp);\n    } // Rebase on delay\n\n\n    const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n    const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    this.currentTime = Math.max(timeWithoutDelay, 0); // If this animation has finished, set the current time  to the total duration.\n\n    if (this.state === \"finished\" && this.holdTime === null) {\n      this.currentTime = totalDuration;\n    }\n\n    let elapsed = this.currentTime;\n    let frameGenerator = generator;\n\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n\n      const isOddIteration = Boolean(currentIteration % 2);\n\n      if (isOddIteration) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n\n      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n    }\n    /**\n     * If we're in negative time, set state as the initial keyframe.\n     * This prevents delay: x, duration: 0 animations from finishing\n     * instantly.\n     */\n\n\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes[0]\n    } : frameGenerator.next(elapsed);\n\n    if (mixKeyframes) {\n      state.value = mixKeyframes(state.value);\n    }\n\n    let {\n      done\n    } = state;\n\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n    }\n\n    const isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done); // TODO: The exception for inertia could be cleaner here\n\n    if (isAnimationFinished && type !== inertia) {\n      state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n    }\n\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n\n    if (isAnimationFinished) {\n      this.finish();\n    }\n\n    return state;\n  }\n  /**\n   * Allows the returned animation to be awaited or promise-chained. Currently\n   * resolves when the animation finishes at all but in a future update could/should\n   * reject if its cancels.\n   */\n\n\n  then(resolve, reject) {\n    return this.finished.then(resolve, reject);\n  }\n\n  get duration() {\n    return millisecondsToSeconds(this.calculatedDuration);\n  }\n\n  get time() {\n    return millisecondsToSeconds(this.currentTime);\n  }\n\n  set time(newTime) {\n    newTime = secondsToMilliseconds(newTime);\n    this.currentTime = newTime;\n\n    if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {\n      this.holdTime = newTime;\n    } else if (this.driver) {\n      this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n    }\n  }\n\n  get speed() {\n    return this.playbackSpeed;\n  }\n\n  set speed(newSpeed) {\n    this.updateTime(time.now());\n    const hasChanged = this.playbackSpeed !== newSpeed;\n    this.playbackSpeed = newSpeed;\n\n    if (hasChanged) {\n      this.time = millisecondsToSeconds(this.currentTime);\n    }\n  }\n\n  play() {\n    if (this.isStopped) return;\n    const {\n      driver = frameloopDriver,\n      onPlay,\n      startTime\n    } = this.options;\n\n    if (!this.driver) {\n      this.driver = driver(timestamp => this.tick(timestamp));\n    }\n\n    onPlay && onPlay();\n    const now = this.driver.now();\n\n    if (this.state === \"finished\") {\n      this.updateFinished();\n      this.startTime = now;\n    } else if (this.holdTime !== null) {\n      this.startTime = now - this.holdTime;\n    } else if (!this.startTime) {\n      this.startTime = startTime ?? now;\n    }\n\n    if (this.state === \"finished\" && this.speed < 0) {\n      this.startTime += this.calculatedDuration;\n    }\n\n    this.holdTime = null;\n    /**\n     * Set playState to running only after we've used it in\n     * the previous logic.\n     */\n\n    this.state = \"running\";\n    this.driver.start();\n  }\n\n  pause() {\n    this.state = \"paused\";\n    this.updateTime(time.now());\n    this.holdTime = this.currentTime;\n  }\n\n  complete() {\n    if (this.state !== \"running\") {\n      this.play();\n    }\n\n    this.state = \"finished\";\n    this.holdTime = null;\n  }\n\n  finish() {\n    this.teardown();\n    this.state = \"finished\";\n    const {\n      onComplete\n    } = this.options;\n    onComplete && onComplete();\n  }\n\n  cancel() {\n    this.holdTime = null;\n    this.startTime = 0;\n    this.tick(0);\n    this.teardown();\n  }\n\n  teardown() {\n    this.notifyFinished();\n    this.state = \"idle\";\n    this.stopDriver();\n    this.startTime = this.holdTime = null;\n    activeAnimations.mainThread--;\n  }\n\n  stopDriver() {\n    if (!this.driver) return;\n    this.driver.stop();\n    this.driver = undefined;\n  }\n\n  sample(sampleTime) {\n    this.startTime = 0;\n    return this.tick(sampleTime, true);\n  }\n\n  attachTimeline(timeline) {\n    if (this.options.allowFlatten) {\n      this.options.type = \"keyframes\";\n      this.options.ease = \"linear\";\n      this.initAnimation();\n    }\n\n    return timeline.observe(this);\n  }\n\n} // Legacy function support\n\n\nfunction animateValue(options) {\n  return new JSAnimation(options);\n}\n\nexport { JSAnimation, animateValue };","map":{"version":3,"names":["invariant","pipe","clamp","millisecondsToSeconds","secondsToMilliseconds","time","activeAnimations","mix","frameloopDriver","inertia","keyframes","calcGeneratorDuration","getFinalKeyframe","replaceTransitionType","WithPromise","percentToProgress","percent","JSAnimation","constructor","options","state","startTime","isStopped","currentTime","holdTime","playbackSpeed","stop","motionValue","updatedAt","now","tick","teardown","onStop","mainThread","initAnimation","play","autoplay","pause","type","repeat","repeatDelay","repeatType","velocity","keyframes$1","generatorFactory","process","env","NODE_ENV","length","mixKeyframes","generator","mirroredGenerator","reverse","calculatedDuration","resolvedDuration","totalDuration","updateTime","timestamp","animationTime","Math","round","sample","next","delay","onUpdate","finalKeyframe","speed","min","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","done","value","isAnimationFinished","finish","then","resolve","reject","finished","duration","newTime","driver","newSpeed","hasChanged","onPlay","updateFinished","start","complete","onComplete","cancel","notifyFinished","stopDriver","undefined","sampleTime","attachTimeline","timeline","allowFlatten","ease","observe","animateValue"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/motion-dom/dist/es/animation/JSAnimation.mjs"],"sourcesContent":["import { invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\n\nconst percentToProgress = (percent) => percent / 100;\nclass JSAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.state = \"idle\";\n        this.startTime = null;\n        this.isStopped = false;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            const { motionValue } = this.options;\n            if (motionValue && motionValue.updatedAt !== time.now()) {\n                this.tick(time.now());\n            }\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        activeAnimations.mainThread++;\n        this.options = options;\n        this.initAnimation();\n        this.play();\n        if (options.autoplay === false)\n            this.pause();\n    }\n    initAnimation() {\n        const { options } = this;\n        replaceTransitionType(options);\n        const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = options;\n        let { keyframes: keyframes$1 } = options;\n        const generatorFactory = type || keyframes;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        this.calculatedDuration = calculatedDuration;\n        this.resolvedDuration = calculatedDuration + repeatDelay;\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n        this.generator = generator;\n    }\n    updateTime(timestamp) {\n        const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = this;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay = 0, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else {\n            this.updateTime(timestamp);\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.playbackSpeed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.finished.then(resolve, reject);\n    }\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration);\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        this.updateTime(time.now());\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n            this.startTime = now;\n        }\n        else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime ?? now;\n        }\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration;\n        }\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        this.state = \"paused\";\n        this.updateTime(time.now());\n        this.holdTime = this.currentTime;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        this.holdTime = null;\n        this.startTime = 0;\n        this.tick(0);\n        this.teardown();\n    }\n    teardown() {\n        this.notifyFinished();\n        this.state = \"idle\";\n        this.stopDriver();\n        this.startTime = this.holdTime = null;\n        activeAnimations.mainThread--;\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(sampleTime) {\n        this.startTime = 0;\n        return this.tick(sampleTime, true);\n    }\n    attachTimeline(timeline) {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\";\n            this.options.ease = \"linear\";\n            this.initAnimation();\n        }\n        return timeline.observe(this);\n    }\n}\n// Legacy function support\nfunction animateValue(options) {\n    return new JSAnimation(options);\n}\n\nexport { JSAnimation, animateValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}