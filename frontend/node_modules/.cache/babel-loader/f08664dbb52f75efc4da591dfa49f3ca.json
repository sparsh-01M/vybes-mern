{"ast":null,"code":"/**\n * @import {\n *   Extension,\n *   Handles,\n *   HtmlExtension,\n *   NormalizedExtension\n * } from 'micromark-util-types'\n */\nimport { splice } from 'micromark-util-chunked';\nconst hasOwnProperty = {}.hasOwnProperty;\n/**\n * Combine multiple syntax extensions into one.\n *\n * @param {ReadonlyArray<Extension>} extensions\n *   List of syntax extensions.\n * @returns {NormalizedExtension}\n *   A single combined extension.\n */\n\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {};\n  let index = -1;\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index]);\n  }\n\n  return all;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all\n *   Extension to merge into.\n * @param {Extension} extension\n *   Extension to merge.\n * @returns {undefined}\n *   Nothing.\n */\n\nfunction syntaxExtension(all, extension) {\n  /** @type {keyof Extension} */\n  let hook;\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n    /** @type {Record<string, unknown>} */\n\n    const left = maybe || (all[hook] = {});\n    /** @type {Record<string, unknown> | undefined} */\n\n    const right = extension[hook];\n    /** @type {string} */\n\n    let code;\n\n    if (right) {\n      for (code in right) {\n        if (!hasOwnProperty.call(left, code)) left[code] = [];\n        const value = right[code];\n        constructs( // @ts-expect-error Looks like a list.\n        left[code], Array.isArray(value) ? value : value ? [value] : []);\n      }\n    }\n  }\n}\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {Array<unknown>} existing\n *   List of constructs to merge into.\n * @param {Array<unknown>} list\n *   List of constructs to merge.\n * @returns {undefined}\n *   Nothing.\n */\n\n\nfunction constructs(existing, list) {\n  let index = -1;\n  /** @type {Array<unknown>} */\n\n  const before = [];\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;\n    (list[index].add === 'after' ? existing : before).push(list[index]);\n  }\n\n  splice(existing, 0, 0, before);\n}\n/**\n * Combine multiple HTML extensions into one.\n *\n * @param {ReadonlyArray<HtmlExtension>} htmlExtensions\n *   List of HTML extensions.\n * @returns {HtmlExtension}\n *   Single combined HTML extension.\n */\n\n\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {};\n  let index = -1;\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index]);\n  }\n\n  return handlers;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all\n *   Extension to merge into.\n * @param {HtmlExtension} extension\n *   Extension to merge.\n * @returns {undefined}\n *   Nothing.\n */\n\nfunction htmlExtension(all, extension) {\n  /** @type {keyof HtmlExtension} */\n  let hook;\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n    const left = maybe || (all[hook] = {});\n    const right = extension[hook];\n    /** @type {keyof Handles} */\n\n    let type;\n\n    if (right) {\n      for (type in right) {\n        // @ts-expect-error assume document vs regular handler are managed correctly.\n        left[type] = right[type];\n      }\n    }\n  }\n}","map":{"version":3,"names":["splice","hasOwnProperty","combineExtensions","extensions","all","index","length","syntaxExtension","extension","hook","maybe","call","undefined","left","right","code","value","constructs","Array","isArray","existing","list","before","add","push","combineHtmlExtensions","htmlExtensions","handlers","htmlExtension","type"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark-util-combine-extensions/index.js"],"sourcesContent":["/**\n * @import {\n *   Extension,\n *   Handles,\n *   HtmlExtension,\n *   NormalizedExtension\n * } from 'micromark-util-types'\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine multiple syntax extensions into one.\n *\n * @param {ReadonlyArray<Extension>} extensions\n *   List of syntax extensions.\n * @returns {NormalizedExtension}\n *   A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all\n *   Extension to merge into.\n * @param {Extension} extension\n *   Extension to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {keyof Extension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    /** @type {Record<string, unknown>} */\n    const left = maybe || (all[hook] = {})\n    /** @type {Record<string, unknown> | undefined} */\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    if (right) {\n      for (code in right) {\n        if (!hasOwnProperty.call(left, code)) left[code] = []\n        const value = right[code]\n        constructs(\n          // @ts-expect-error Looks like a list.\n          left[code],\n          Array.isArray(value) ? value : value ? [value] : []\n        )\n      }\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {Array<unknown>} existing\n *   List of constructs to merge into.\n * @param {Array<unknown>} list\n *   List of constructs to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {Array<unknown>} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine multiple HTML extensions into one.\n *\n * @param {ReadonlyArray<HtmlExtension>} htmlExtensions\n *   List of HTML extensions.\n * @returns {HtmlExtension}\n *   Single combined HTML extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all\n *   Extension to merge into.\n * @param {HtmlExtension} extension\n *   Extension to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction htmlExtension(all, extension) {\n  /** @type {keyof HtmlExtension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {keyof Handles} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        // @ts-expect-error assume document vs regular handler are managed correctly.\n        left[type] = right[type]\n      }\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,MAAR,QAAqB,wBAArB;AAEA,MAAMC,cAAc,GAAG,GAAGA,cAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,iBAAT,CAA2BC,UAA3B,EAAuC;EAC5C;EACA,MAAMC,GAAG,GAAG,EAAZ;EACA,IAAIC,KAAK,GAAG,CAAC,CAAb;;EAEA,OAAO,EAAEA,KAAF,GAAUF,UAAU,CAACG,MAA5B,EAAoC;IAClCC,eAAe,CAACH,GAAD,EAAMD,UAAU,CAACE,KAAD,CAAhB,CAAf;EACD;;EAED,OAAOD,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASG,eAAT,CAAyBH,GAAzB,EAA8BI,SAA9B,EAAyC;EACvC;EACA,IAAIC,IAAJ;;EAEA,KAAKA,IAAL,IAAaD,SAAb,EAAwB;IACtB,MAAME,KAAK,GAAGT,cAAc,CAACU,IAAf,CAAoBP,GAApB,EAAyBK,IAAzB,IAAiCL,GAAG,CAACK,IAAD,CAApC,GAA6CG,SAA3D;IACA;;IACA,MAAMC,IAAI,GAAGH,KAAK,KAAKN,GAAG,CAACK,IAAD,CAAH,GAAY,EAAjB,CAAlB;IACA;;IACA,MAAMK,KAAK,GAAGN,SAAS,CAACC,IAAD,CAAvB;IACA;;IACA,IAAIM,IAAJ;;IAEA,IAAID,KAAJ,EAAW;MACT,KAAKC,IAAL,IAAaD,KAAb,EAAoB;QAClB,IAAI,CAACb,cAAc,CAACU,IAAf,CAAoBE,IAApB,EAA0BE,IAA1B,CAAL,EAAsCF,IAAI,CAACE,IAAD,CAAJ,GAAa,EAAb;QACtC,MAAMC,KAAK,GAAGF,KAAK,CAACC,IAAD,CAAnB;QACAE,UAAU,EACR;QACAJ,IAAI,CAACE,IAAD,CAFI,EAGRG,KAAK,CAACC,OAAN,CAAcH,KAAd,IAAuBA,KAAvB,GAA+BA,KAAK,GAAG,CAACA,KAAD,CAAH,GAAa,EAHzC,CAAV;MAKD;IACF;EACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBG,QAApB,EAA8BC,IAA9B,EAAoC;EAClC,IAAIhB,KAAK,GAAG,CAAC,CAAb;EACA;;EACA,MAAMiB,MAAM,GAAG,EAAf;;EAEA,OAAO,EAAEjB,KAAF,GAAUgB,IAAI,CAACf,MAAtB,EAA8B;IAC5B;IACA;IAAC,CAACe,IAAI,CAAChB,KAAD,CAAJ,CAAYkB,GAAZ,KAAoB,OAApB,GAA8BH,QAA9B,GAAyCE,MAA1C,EAAkDE,IAAlD,CAAuDH,IAAI,CAAChB,KAAD,CAA3D;EACF;;EAEDL,MAAM,CAACoB,QAAD,EAAW,CAAX,EAAc,CAAd,EAAiBE,MAAjB,CAAN;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASG,qBAAT,CAA+BC,cAA/B,EAA+C;EACpD;EACA,MAAMC,QAAQ,GAAG,EAAjB;EACA,IAAItB,KAAK,GAAG,CAAC,CAAb;;EAEA,OAAO,EAAEA,KAAF,GAAUqB,cAAc,CAACpB,MAAhC,EAAwC;IACtCsB,aAAa,CAACD,QAAD,EAAWD,cAAc,CAACrB,KAAD,CAAzB,CAAb;EACD;;EAED,OAAOsB,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBxB,GAAvB,EAA4BI,SAA5B,EAAuC;EACrC;EACA,IAAIC,IAAJ;;EAEA,KAAKA,IAAL,IAAaD,SAAb,EAAwB;IACtB,MAAME,KAAK,GAAGT,cAAc,CAACU,IAAf,CAAoBP,GAApB,EAAyBK,IAAzB,IAAiCL,GAAG,CAACK,IAAD,CAApC,GAA6CG,SAA3D;IACA,MAAMC,IAAI,GAAGH,KAAK,KAAKN,GAAG,CAACK,IAAD,CAAH,GAAY,EAAjB,CAAlB;IACA,MAAMK,KAAK,GAAGN,SAAS,CAACC,IAAD,CAAvB;IACA;;IACA,IAAIoB,IAAJ;;IAEA,IAAIf,KAAJ,EAAW;MACT,KAAKe,IAAL,IAAaf,KAAb,EAAoB;QAClB;QACAD,IAAI,CAACgB,IAAD,CAAJ,GAAaf,KAAK,CAACe,IAAD,CAAlB;MACD;IACF;EACF;AACF"},"metadata":{},"sourceType":"module"}