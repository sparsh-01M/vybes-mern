{"ast":null,"code":"/**\n * @import {Identifier, Literal, MemberExpression} from 'estree'\n * @import {Jsx, JsxDev, Options, Props} from 'hast-util-to-jsx-runtime'\n * @import {Element, Nodes, Parents, Root, Text} from 'hast'\n * @import {MdxFlowExpressionHast, MdxTextExpressionHast} from 'mdast-util-mdx-expression'\n * @import {MdxJsxFlowElementHast, MdxJsxTextElementHast} from 'mdast-util-mdx-jsx'\n * @import {MdxjsEsmHast} from 'mdast-util-mdxjs-esm'\n * @import {Position} from 'unist'\n * @import {Child, Create, Field, JsxElement, State, Style} from './types.js'\n */\nimport { stringify as commas } from 'comma-separated-tokens';\nimport { ok as assert } from 'devlop';\nimport { name as isIdentifierName } from 'estree-util-is-identifier-name';\nimport { whitespace } from 'hast-util-whitespace';\nimport { find, hastToReact, html, svg } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport styleToJs from 'style-to-js';\nimport { pointStart } from 'unist-util-position';\nimport { VFileMessage } from 'vfile-message'; // To do: next major: `Object.hasOwn`.\n\nconst own = {}.hasOwnProperty;\n/** @type {Map<string, number>} */\n\nconst emptyMap = new Map();\nconst cap = /[A-Z]/g; // `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they don’t do here, so we remove all of\n// that.\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\n\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr']);\nconst tableCellElement = new Set(['td', 'th']);\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime';\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JsxElement}\n *   JSX element.\n */\n\nexport function toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options');\n  }\n\n  const filePath = options.filePath || undefined;\n  /** @type {Create} */\n\n  let create;\n\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError('Expected `jsxDEV` in options when `development: true`');\n    }\n\n    create = developmentCreate(filePath, options.jsxDEV);\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options');\n    }\n\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options');\n    }\n\n    create = productionCreate(filePath, options.jsx, options.jsxs);\n  }\n  /** @type {State} */\n\n\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  };\n  const result = one(state, tree, undefined); // JSX element.\n\n  if (result && typeof result !== 'string') {\n    return result;\n  } // Text node or something that turned into nothing.\n\n\n  return state.create(tree, state.Fragment, {\n    children: result || undefined\n  }, undefined);\n}\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\n\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key);\n  }\n\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node);\n  }\n\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key);\n  }\n\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node);\n  }\n\n  if (node.type === 'root') {\n    return root(state, node, key);\n  }\n\n  if (node.type === 'text') {\n    return text(state, node);\n  }\n}\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\n\n\nfunction element(state, node, key) {\n  const parentSchema = state.schema;\n  let schema = parentSchema;\n\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = svg;\n    state.schema = schema;\n  }\n\n  state.ancestors.push(node);\n  const type = findComponentFromName(state, node.tagName, false);\n  const props = createElementProps(state, node);\n  let children = createChildren(state, node);\n\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !whitespace(child) : true;\n    });\n  }\n\n  addNode(state, props, type, node);\n  addChildren(props, children); // Restore.\n\n  state.ancestors.pop();\n  state.schema = parentSchema;\n  return state.create(node, type, props, key);\n}\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpressionHast | MdxTextExpressionHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\n\n\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree;\n    const expression = program.body[0];\n    assert(expression.type === 'ExpressionStatement'); // Assume result is a child.\n\n    return (\n      /** @type {Child | undefined} */\n      state.evaluater.evaluateExpression(expression.expression)\n    );\n  }\n\n  crashEstree(state, node.position);\n}\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsmHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\n\n\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return (\n      /** @type {Child | undefined} */\n      state.evaluater.evaluateProgram(node.data.estree)\n    );\n  }\n\n  crashEstree(state, node.position);\n}\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\n\n\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema;\n  let schema = parentSchema;\n\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = svg;\n    state.schema = schema;\n  }\n\n  state.ancestors.push(node);\n  const type = node.name === null ? state.Fragment : findComponentFromName(state, node.name, true);\n  const props = createJsxElementProps(state, node);\n  const children = createChildren(state, node);\n  addNode(state, props, type, node);\n  addChildren(props, children); // Restore.\n\n  state.ancestors.pop();\n  state.schema = parentSchema;\n  return state.create(node, type, props, key);\n}\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\n\n\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {};\n  addChildren(props, createChildren(state, node));\n  return state.create(node, state.Fragment, props, key);\n}\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\n\n\nfunction text(_, node) {\n  return node.value;\n}\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */\n\n\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node;\n  }\n}\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */\n\n\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0];\n\n    if (value) {\n      props.children = value;\n    }\n  }\n}\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */\n\n\nfunction productionCreate(_, jsx, jsxs) {\n  return create;\n  /** @type {Create} */\n\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children);\n    const fn = isStaticChildren ? jsxs : jsx;\n    return key ? fn(type, props, key) : fn(type, props);\n  }\n}\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */\n\n\nfunction developmentCreate(filePath, jsxDEV) {\n  return create;\n  /** @type {Create} */\n\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children);\n    const point = pointStart(node);\n    return jsxDEV(type, props, key, isStaticChildren, {\n      columnNumber: point ? point.column - 1 : undefined,\n      fileName: filePath,\n      lineNumber: point ? point.line : undefined\n    }, undefined);\n  }\n}\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */\n\n\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {};\n  /** @type {string | undefined} */\n\n  let alignValue;\n  /** @type {string} */\n\n  let prop;\n\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop]);\n\n      if (result) {\n        const [key, value] = result;\n\n        if (state.tableCellAlignToStyle && key === 'align' && typeof value === 'string' && tableCellElement.has(node.tagName)) {\n          alignValue = value;\n        } else {\n          props[key] = value;\n        }\n      }\n    }\n  }\n\n  if (alignValue) {\n    // Assume style is an object.\n    const style =\n    /** @type {Style} */\n    props.style || (props.style = {});\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] = alignValue;\n  }\n\n  return props;\n}\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */\n\n\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {};\n\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree;\n        const expression = program.body[0];\n        assert(expression.type === 'ExpressionStatement');\n        const objectExpression = expression.expression;\n        assert(objectExpression.type === 'ObjectExpression');\n        const property = objectExpression.properties[0];\n        assert(property.type === 'SpreadElement');\n        Object.assign(props, state.evaluater.evaluateExpression(property.argument));\n      } else {\n        crashEstree(state, node.position);\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name;\n      /** @type {unknown} */\n\n      let value;\n\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {\n          const program = attribute.value.data.estree;\n          const expression = program.body[0];\n          assert(expression.type === 'ExpressionStatement');\n          value = state.evaluater.evaluateExpression(expression.expression);\n        } else {\n          crashEstree(state, node.position);\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value;\n      } // Assume a prop.\n\n\n      props[name] =\n      /** @type {Props[keyof Props]} */\n      value;\n    }\n  }\n\n  return props;\n}\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */\n\n\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = [];\n  let index = -1;\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesn’t want to merge my upcoming PR.\n\n  /* c8 ignore next */\n\n  const countsByName = state.passKeys ? new Map() : emptyMap;\n\n  while (++index < node.children.length) {\n    const child = node.children[index];\n    /** @type {string | undefined} */\n\n    let key;\n\n    if (state.passKeys) {\n      const name = child.type === 'element' ? child.tagName : child.type === 'mdxJsxFlowElement' || child.type === 'mdxJsxTextElement' ? child.name : undefined;\n\n      if (name) {\n        const count = countsByName.get(name) || 0;\n        key = name + '-' + count;\n        countsByName.set(name, count + 1);\n      }\n    }\n\n    const result = one(state, child, key);\n    if (result !== undefined) children.push(result);\n  }\n\n  return children;\n}\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */\n\n\nfunction createProperty(state, prop, value) {\n  const info = find(state.schema, prop); // Ignore nullish and `NaN` values.\n\n  if (value === null || value === undefined || typeof value === 'number' && Number.isNaN(value)) {\n    return;\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value);\n  } // React only accepts `style` as object.\n\n\n  if (info.property === 'style') {\n    let styleObject = typeof value === 'object' ? value : parseStyle(state, String(value));\n\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject);\n    }\n\n    return ['style', styleObject];\n  }\n\n  return [state.elementAttributeNameCase === 'react' && info.space ? hastToReact[info.property] || info.property : info.attribute, value];\n}\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */\n\n\nfunction parseStyle(state, value) {\n  try {\n    return styleToJs(value, {\n      reactCompat: true\n    });\n  } catch (error) {\n    if (state.ignoreInvalidStyle) {\n      return {};\n    }\n\n    const cause =\n    /** @type {Error} */\n    error;\n    const message = new VFileMessage('Cannot parse `style` attribute', {\n      ancestors: state.ancestors,\n      cause,\n      ruleId: 'style',\n      source: 'hast-util-to-jsx-runtime'\n    });\n    message.file = state.filePath || undefined;\n    message.url = docs + '#cannot-parse-style-attribute';\n    throw message;\n  }\n}\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */\n\n\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result;\n\n  if (!allowExpression) {\n    result = {\n      type: 'Literal',\n      value: name\n    };\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.');\n    let index = -1;\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n\n    let node;\n\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = isIdentifierName(identifiers[index]) ? {\n        type: 'Identifier',\n        name: identifiers[index]\n      } : {\n        type: 'Literal',\n        value: identifiers[index]\n      };\n      node = node ? {\n        type: 'MemberExpression',\n        object: node,\n        property: prop,\n        computed: Boolean(index && prop.type === 'Literal'),\n        optional: false\n      } : prop;\n    }\n\n    assert(node, 'always a result');\n    result = node;\n  } else {\n    result = isIdentifierName(name) && !/^[a-z]/.test(name) ? {\n      type: 'Identifier',\n      name\n    } : {\n      type: 'Literal',\n      value: name\n    };\n  } // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n\n\n  if (result.type === 'Literal') {\n    const name =\n    /** @type {string | number} */\n    result.value;\n    return own.call(state.components, name) ? state.components[name] : name;\n  } // Assume component.\n\n\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result);\n  }\n\n  crashEstree(state);\n}\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */\n\n\nfunction crashEstree(state, place) {\n  const message = new VFileMessage('Cannot handle MDX estrees without `createEvaluater`', {\n    ancestors: state.ancestors,\n    place,\n    ruleId: 'mdx-estree',\n    source: 'hast-util-to-jsx-runtime'\n  });\n  message.file = state.filePath || undefined;\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater';\n  throw message;\n}\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\n\n\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {};\n  /** @type {string} */\n\n  let from;\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from];\n    }\n  }\n\n  return cssCasing;\n}\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */\n\n\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash); // Handle `ms-xxx` -> `-ms-xxx`.\n\n  if (to.slice(0, 3) === 'ms-') to = '-' + to;\n  return to;\n}\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\n\n\nfunction toDash($0) {\n  return '-' + $0.toLowerCase();\n}","map":{"version":3,"names":["stringify","commas","ok","assert","name","isIdentifierName","whitespace","find","hastToReact","html","svg","spaces","styleToJs","pointStart","VFileMessage","own","hasOwnProperty","emptyMap","Map","cap","tableElements","Set","tableCellElement","docs","toJsxRuntime","tree","options","Fragment","undefined","TypeError","filePath","create","development","jsxDEV","developmentCreate","jsx","jsxs","productionCreate","state","ancestors","components","elementAttributeNameCase","evaluater","createEvaluater","ignoreInvalidStyle","passKeys","passNode","schema","space","stylePropertyNameCase","tableCellAlignToStyle","result","one","children","node","key","type","element","mdxExpression","mdxJsxElement","mdxEsm","root","text","parentSchema","tagName","toLowerCase","push","findComponentFromName","props","createElementProps","createChildren","has","filter","child","addNode","addChildren","pop","data","estree","program","expression","body","evaluateExpression","crashEstree","position","evaluateProgram","createJsxElementProps","_","value","length","isStaticChildren","Array","isArray","fn","point","columnNumber","column","fileName","lineNumber","line","alignValue","prop","properties","call","createProperty","style","attribute","attributes","objectExpression","property","Object","assign","argument","index","countsByName","count","get","set","info","Number","isNaN","commaSeparated","styleObject","parseStyle","String","transformStylesToCssCasing","reactCompat","error","cause","message","ruleId","source","file","url","allowExpression","includes","identifiers","split","object","computed","Boolean","optional","test","place","domCasing","cssCasing","from","transformStyleToCssCasing","to","replace","toDash","slice","$0"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/hast-util-to-jsx-runtime/lib/index.js"],"sourcesContent":["/**\n * @import {Identifier, Literal, MemberExpression} from 'estree'\n * @import {Jsx, JsxDev, Options, Props} from 'hast-util-to-jsx-runtime'\n * @import {Element, Nodes, Parents, Root, Text} from 'hast'\n * @import {MdxFlowExpressionHast, MdxTextExpressionHast} from 'mdast-util-mdx-expression'\n * @import {MdxJsxFlowElementHast, MdxJsxTextElementHast} from 'mdast-util-mdx-jsx'\n * @import {MdxjsEsmHast} from 'mdast-util-mdxjs-esm'\n * @import {Position} from 'unist'\n * @import {Child, Create, Field, JsxElement, State, Style} from './types.js'\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\nimport {whitespace} from 'hast-util-whitespace'\nimport {find, hastToReact, html, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport styleToJs from 'style-to-js'\nimport {pointStart} from 'unist-util-position'\nimport {VFileMessage} from 'vfile-message'\n\n// To do: next major: `Object.hasOwn`.\nconst own = {}.hasOwnProperty\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map()\n\nconst cap = /[A-Z]/g\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they don’t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\n\nconst tableCellElement = new Set(['td', 'th'])\n\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime'\n\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JsxElement}\n *   JSX element.\n */\n\nexport function toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options')\n  }\n\n  const filePath = options.filePath || undefined\n  /** @type {Create} */\n  let create\n\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError(\n        'Expected `jsxDEV` in options when `development: true`'\n      )\n    }\n\n    create = developmentCreate(filePath, options.jsxDEV)\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options')\n    }\n\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options')\n    }\n\n    create = productionCreate(filePath, options.jsx, options.jsxs)\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  }\n\n  const result = one(state, tree, undefined)\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(\n    tree,\n    state.Fragment,\n    {children: result || undefined},\n    undefined\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key)\n  }\n\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node)\n  }\n\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key)\n  }\n\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node)\n  }\n\n  if (node.type === 'root') {\n    return root(state, node, key)\n  }\n\n  if (node.type === 'text') {\n    return text(state, node)\n  }\n}\n\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction element(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type = findComponentFromName(state, node.tagName, false)\n  const props = createElementProps(state, node)\n  let children = createChildren(state, node)\n\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !whitespace(child) : true\n    })\n  }\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpressionHast | MdxTextExpressionHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree\n    const expression = program.body[0]\n    assert(expression.type === 'ExpressionStatement')\n\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateExpression(expression.expression)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsmHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateProgram(node.data.estree)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type =\n    node.name === null\n      ? state.Fragment\n      : findComponentFromName(state, node.name, true)\n  const props = createJsxElementProps(state, node)\n  const children = createChildren(state, node)\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {}\n\n  addChildren(props, createChildren(state, node))\n\n  return state.create(node, state.Fragment, props, key)\n}\n\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction text(_, node) {\n  return node.value\n}\n\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node\n  }\n}\n\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0]\n\n    if (value) {\n      props.children = value\n    }\n  }\n}\n\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const fn = isStaticChildren ? jsxs : jsx\n    return key ? fn(type, props, key) : fn(type, props)\n  }\n}\n\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const point = pointStart(node)\n    return jsxDEV(\n      type,\n      props,\n      key,\n      isStaticChildren,\n      {\n        columnNumber: point ? point.column - 1 : undefined,\n        fileName: filePath,\n        lineNumber: point ? point.line : undefined\n      },\n      undefined\n    )\n  }\n}\n\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n  /** @type {string | undefined} */\n  let alignValue\n  /** @type {string} */\n  let prop\n\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop])\n\n      if (result) {\n        const [key, value] = result\n\n        if (\n          state.tableCellAlignToStyle &&\n          key === 'align' &&\n          typeof value === 'string' &&\n          tableCellElement.has(node.tagName)\n        ) {\n          alignValue = value\n        } else {\n          props[key] = value\n        }\n      }\n    }\n  }\n\n  if (alignValue) {\n    // Assume style is an object.\n    const style = /** @type {Style} */ (props.style || (props.style = {}))\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] =\n      alignValue\n  }\n\n  return props\n}\n\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree\n        const expression = program.body[0]\n        assert(expression.type === 'ExpressionStatement')\n        const objectExpression = expression.expression\n        assert(objectExpression.type === 'ObjectExpression')\n        const property = objectExpression.properties[0]\n        assert(property.type === 'SpreadElement')\n\n        Object.assign(\n          props,\n          state.evaluater.evaluateExpression(property.argument)\n        )\n      } else {\n        crashEstree(state, node.position)\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name\n      /** @type {unknown} */\n      let value\n\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (\n          attribute.value.data &&\n          attribute.value.data.estree &&\n          state.evaluater\n        ) {\n          const program = attribute.value.data.estree\n          const expression = program.body[0]\n          assert(expression.type === 'ExpressionStatement')\n          value = state.evaluater.evaluateExpression(expression.expression)\n        } else {\n          crashEstree(state, node.position)\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value\n      }\n\n      // Assume a prop.\n      props[name] = /** @type {Props[keyof Props]} */ (value)\n    }\n  }\n\n  return props\n}\n\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = []\n  let index = -1\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesn’t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByName = state.passKeys ? new Map() : emptyMap\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    /** @type {string | undefined} */\n    let key\n\n    if (state.passKeys) {\n      const name =\n        child.type === 'element'\n          ? child.tagName\n          : child.type === 'mdxJsxFlowElement' ||\n              child.type === 'mdxJsxTextElement'\n            ? child.name\n            : undefined\n\n      if (name) {\n        const count = countsByName.get(name) || 0\n        key = name + '-' + count\n        countsByName.set(name, count + 1)\n      }\n    }\n\n    const result = one(state, child, key)\n    if (result !== undefined) children.push(result)\n  }\n\n  return children\n}\n\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(state, prop, value) {\n  const info = find(state.schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject =\n      typeof value === 'object' ? value : parseStyle(state, String(value))\n\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject)\n    }\n\n    return ['style', styleObject]\n  }\n\n  return [\n    state.elementAttributeNameCase === 'react' && info.space\n      ? hastToReact[info.property] || info.property\n      : info.attribute,\n    value\n  ]\n}\n\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */\nfunction parseStyle(state, value) {\n  try {\n    return styleToJs(value, {reactCompat: true})\n  } catch (error) {\n    if (state.ignoreInvalidStyle) {\n      return {}\n    }\n\n    const cause = /** @type {Error} */ (error)\n    const message = new VFileMessage('Cannot parse `style` attribute', {\n      ancestors: state.ancestors,\n      cause,\n      ruleId: 'style',\n      source: 'hast-util-to-jsx-runtime'\n    })\n    message.file = state.filePath || undefined\n    message.url = docs + '#cannot-parse-style-attribute'\n\n    throw message\n  }\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result\n\n  if (!allowExpression) {\n    result = {type: 'Literal', value: name}\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.')\n    let index = -1\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let node\n\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = isIdentifierName(identifiers[index])\n        ? {type: 'Identifier', name: identifiers[index]}\n        : {type: 'Literal', value: identifiers[index]}\n      node = node\n        ? {\n            type: 'MemberExpression',\n            object: node,\n            property: prop,\n            computed: Boolean(index && prop.type === 'Literal'),\n            optional: false\n          }\n        : prop\n    }\n\n    assert(node, 'always a result')\n    result = node\n  } else {\n    result =\n      isIdentifierName(name) && !/^[a-z]/.test(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n  }\n\n  // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n  if (result.type === 'Literal') {\n    const name = /** @type {string | number} */ (result.value)\n    return own.call(state.components, name) ? state.components[name] : name\n  }\n\n  // Assume component.\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result)\n  }\n\n  crashEstree(state)\n}\n\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */\nfunction crashEstree(state, place) {\n  const message = new VFileMessage(\n    'Cannot handle MDX estrees without `createEvaluater`',\n    {\n      ancestors: state.ancestors,\n      place,\n      ruleId: 'mdx-estree',\n      source: 'hast-util-to-jsx-runtime'\n    }\n  )\n  message.file = state.filePath || undefined\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater'\n\n  throw message\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash)\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\n  return to\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}