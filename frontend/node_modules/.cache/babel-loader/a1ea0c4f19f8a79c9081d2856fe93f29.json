{"ast":null,"code":"/**\n * @import {\n *   Construct,\n *   Exiter,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\nimport { ok as assert } from 'devlop';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownSpace } from 'micromark-util-character';\nimport { codes, constants, types } from 'micromark-util-symbol';\n/** @type {Construct} */\n\nexport const blockQuote = {\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit,\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart\n};\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this;\n  return start;\n  /**\n   * Start of block quote.\n   *\n   * ```markdown\n   * > | > a\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    if (code === codes.greaterThan) {\n      const state = self.containerState;\n      assert(state, 'expected `containerState` to be defined in container');\n\n      if (!state.open) {\n        effects.enter(types.blockQuote, {\n          _container: true\n        });\n        state.open = true;\n      }\n\n      effects.enter(types.blockQuotePrefix);\n      effects.enter(types.blockQuoteMarker);\n      effects.consume(code);\n      effects.exit(types.blockQuoteMarker);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `>`, before optional whitespace.\n   *\n   * ```markdown\n   * > | > a\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.blockQuotePrefixWhitespace);\n      effects.consume(code);\n      effects.exit(types.blockQuotePrefixWhitespace);\n      effects.exit(types.blockQuotePrefix);\n      return ok;\n    }\n\n    effects.exit(types.blockQuotePrefix);\n    return ok(code);\n  }\n}\n/**\n * Start of block quote continuation.\n *\n * ```markdown\n *   | > a\n * > | > b\n *     ^\n * ```\n *\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  const self = this;\n  return contStart;\n  /**\n   * Start of block quote continuation.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function contStart(code) {\n    if (markdownSpace(code)) {\n      // Always populated by defaults.\n      assert(self.parser.constructs.disable.null, 'expected `disable.null` to be populated');\n      return factorySpace(effects, contBefore, types.linePrefix, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize)(code);\n    }\n\n    return contBefore(code);\n  }\n  /**\n   * At `>`, after optional whitespace.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function contBefore(code) {\n    return effects.attempt(blockQuote, ok, nok)(code);\n  }\n}\n/** @type {Exiter} */\n\n\nfunction exit(effects) {\n  effects.exit(types.blockQuote);\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownSpace","codes","constants","types","blockQuote","continuation","tokenize","tokenizeBlockQuoteContinuation","exit","name","tokenizeBlockQuoteStart","effects","nok","self","start","code","greaterThan","state","containerState","open","enter","_container","blockQuotePrefix","blockQuoteMarker","consume","after","blockQuotePrefixWhitespace","contStart","parser","constructs","disable","null","contBefore","linePrefix","includes","undefined","tabSize","attempt"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark-core-commonmark/dev/lib/block-quote.js"],"sourcesContent":["/**\n * @import {\n *   Construct,\n *   Exiter,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  continuation: {tokenize: tokenizeBlockQuoteContinuation},\n  exit,\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * Start of block quote.\n   *\n   * ```markdown\n   * > | > a\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === codes.greaterThan) {\n      const state = self.containerState\n\n      assert(state, 'expected `containerState` to be defined in container')\n\n      if (!state.open) {\n        effects.enter(types.blockQuote, {_container: true})\n        state.open = true\n      }\n\n      effects.enter(types.blockQuotePrefix)\n      effects.enter(types.blockQuoteMarker)\n      effects.consume(code)\n      effects.exit(types.blockQuoteMarker)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `>`, before optional whitespace.\n   *\n   * ```markdown\n   * > | > a\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.blockQuotePrefixWhitespace)\n      effects.consume(code)\n      effects.exit(types.blockQuotePrefixWhitespace)\n      effects.exit(types.blockQuotePrefix)\n      return ok\n    }\n\n    effects.exit(types.blockQuotePrefix)\n    return ok(code)\n  }\n}\n\n/**\n * Start of block quote continuation.\n *\n * ```markdown\n *   | > a\n * > | > b\n *     ^\n * ```\n *\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  const self = this\n\n  return contStart\n\n  /**\n   * Start of block quote continuation.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contStart(code) {\n    if (markdownSpace(code)) {\n      // Always populated by defaults.\n      assert(\n        self.parser.constructs.disable.null,\n        'expected `disable.null` to be populated'\n      )\n\n      return factorySpace(\n        effects,\n        contBefore,\n        types.linePrefix,\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : constants.tabSize\n      )(code)\n    }\n\n    return contBefore(code)\n  }\n\n  /**\n   * At `>`, after optional whitespace.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contBefore(code) {\n    return effects.attempt(blockQuote, ok, nok)(code)\n  }\n}\n\n/** @type {Exiter} */\nfunction exit(effects) {\n  effects.exit(types.blockQuote)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}