{"ast":null,"code":"import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  const elements = resolveElements(elementOrSelector, scope);\n  const numElements = elements.length;\n  invariant(Boolean(numElements), \"No valid element provided.\");\n  /**\n   * WAAPI doesn't support interrupting animations.\n   *\n   * Therefore, starting animations requires a three-step process:\n   * 1. Stop existing animations (write styles to DOM)\n   * 2. Resolve keyframes (read styles from DOM)\n   * 3. Create new animations (write styles to DOM)\n   *\n   * The hybrid `animate()` function uses AsyncAnimation to resolve\n   * keyframes before creating new animations, which removes style\n   * thrashing. Here, we have much stricter filesize constraints.\n   * Therefore we do this in a synchronous way that ensures that\n   * at least within `animate()` calls there is no style thrashing.\n   *\n   * In the motion-native-animate-mini-interrupt benchmark this\n   * was 80% faster than a single loop.\n   */\n\n  const animationDefinitions = [];\n  /**\n   * Step 1: Build options and stop existing animations (write)\n   */\n\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    const elementTransition = { ...options\n    };\n    /**\n     * Resolve stagger function if provided.\n     */\n\n    if (typeof elementTransition.delay === \"function\") {\n      elementTransition.delay = elementTransition.delay(i, numElements);\n    }\n\n    for (const valueName in keyframes) {\n      let valueKeyframes = keyframes[valueName];\n\n      if (!Array.isArray(valueKeyframes)) {\n        valueKeyframes = [valueKeyframes];\n      }\n\n      const valueOptions = { ...getValueTransition(elementTransition, valueName)\n      };\n      valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n      valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n      /**\n       * If there's an existing animation playing on this element then stop it\n       * before creating a new one.\n       */\n\n      const map = getAnimationMap(element);\n      const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n      const currentAnimation = map.get(key);\n      currentAnimation && currentAnimation.stop();\n      animationDefinitions.push({\n        map,\n        key,\n        unresolvedKeyframes: valueKeyframes,\n        options: { ...valueOptions,\n          element,\n          name: valueName,\n          allowFlatten: !elementTransition.type && !elementTransition.ease\n        }\n      });\n    }\n  }\n  /**\n   * Step 2: Resolve keyframes (read)\n   */\n\n\n  for (let i = 0; i < animationDefinitions.length; i++) {\n    const {\n      unresolvedKeyframes,\n      options: animationOptions\n    } = animationDefinitions[i];\n    const {\n      element,\n      name,\n      pseudoElement\n    } = animationOptions;\n\n    if (!pseudoElement && unresolvedKeyframes[0] === null) {\n      unresolvedKeyframes[0] = getComputedStyle(element, name);\n    }\n\n    fillWildcards(unresolvedKeyframes);\n    applyPxDefaults(unresolvedKeyframes, name);\n    /**\n     * If we only have one keyframe, explicitly read the initial keyframe\n     * from the computed style. This is to ensure consistency with WAAPI behaviour\n     * for restarting animations, for instance .play() after finish, when it\n     * has one vs two keyframes.\n     */\n\n    if (!pseudoElement && unresolvedKeyframes.length < 2) {\n      unresolvedKeyframes.unshift(getComputedStyle(element, name));\n    }\n\n    animationOptions.keyframes = unresolvedKeyframes;\n  }\n  /**\n   * Step 3: Create new animations (write)\n   */\n\n\n  const animations = [];\n\n  for (let i = 0; i < animationDefinitions.length; i++) {\n    const {\n      map,\n      key,\n      options: animationOptions\n    } = animationDefinitions[i];\n    const animation = new NativeAnimation(animationOptions);\n    map.set(key, animation);\n    animation.finished.finally(() => map.delete(key));\n    animations.push(animation);\n  }\n\n  return animations;\n}\n\nexport { animateElements };","map":{"version":3,"names":["resolveElements","getValueTransition","getAnimationMap","animationMapKey","getComputedStyle","fillWildcards","applyPxDefaults","NativeAnimation","invariant","secondsToMilliseconds","animateElements","elementOrSelector","keyframes","options","scope","elements","numElements","length","Boolean","animationDefinitions","i","element","elementTransition","delay","valueName","valueKeyframes","Array","isArray","valueOptions","duration","map","key","pseudoElement","currentAnimation","get","stop","push","unresolvedKeyframes","name","allowFlatten","type","ease","animationOptions","unshift","animations","animation","set","finished","finally","delete"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/framer-motion/dist/es/animation/animators/waapi/animate-elements.mjs"],"sourcesContent":["import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    invariant(Boolean(numElements), \"No valid element provided.\");\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions = [];\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        const elementTransition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements);\n        }\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName];\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes];\n            }\n            const valueOptions = {\n                ...getValueTransition(elementTransition, valueName),\n            };\n            valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n            valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element);\n            const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n            const currentAnimation = map.get(key);\n            currentAnimation && currentAnimation.stop();\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten: !elementTransition.type && !elementTransition.ease,\n                },\n            });\n        }\n    }\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];\n        const { element, name, pseudoElement } = animationOptions;\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name);\n        }\n        fillWildcards(unresolvedKeyframes);\n        applyPxDefaults(unresolvedKeyframes, name);\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name));\n        }\n        animationOptions.keyframes = unresolvedKeyframes;\n    }\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations = [];\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i];\n        const animation = new NativeAnimation(animationOptions);\n        map.set(key, animation);\n        animation.finished.finally(() => map.delete(key));\n        animations.push(animation);\n    }\n    return animations;\n}\n\nexport { animateElements };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}