{"ast":null,"code":"/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: '↩'}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the `↩`\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `↩` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\nimport structuredClone from '@ungap/structured-clone';\nimport { visit } from 'unist-util-visit';\nimport { position } from 'unist-util-position';\nimport { handlers as defaultHandlers } from './handlers/index.js';\nconst own = {}.hasOwnProperty;\n/** @type {Options} */\n\nconst emptyOptions = {};\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\n\nexport function createState(tree, options) {\n  const settings = options || emptyOptions;\n  /** @type {Map<string, MdastDefinition>} */\n\n  const definitionById = new Map();\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n\n  const footnoteById = new Map();\n  /** @type {Map<string, number>} */\n\n  const footnoteCounts = new Map();\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n\n  const handlers = { ...defaultHandlers,\n    ...settings.handlers\n  };\n  /** @type {State} */\n\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  };\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById;\n      const id = String(node.identifier).toUpperCase(); // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node);\n      }\n    }\n  });\n  return state;\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n\n  function one(node, parent) {\n    const type = node.type;\n    const handle = state.handlers[type];\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent);\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {\n          children,\n          ...shallow\n        } = node;\n        const result = structuredClone(shallow); // @ts-expect-error: TS doesn’t understand…\n\n        result.children = state.all(node); // @ts-expect-error: TS doesn’t understand…\n\n        return result;\n      } // @ts-expect-error: it’s custom.\n\n\n      return structuredClone(node);\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler;\n    return unknown(state, node, parent);\n  }\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n\n\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = [];\n\n    if ('children' in parent) {\n      const nodes = parent.children;\n      let index = -1;\n\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent); // To do: see if we van clean this? Can we merge texts?\n\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value);\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0];\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value);\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result);\n          } else {\n            values.push(result);\n          }\n        }\n      }\n    }\n\n    return values;\n  }\n}\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\n\nfunction patch(from, to) {\n  if (from.position) to.position = position(from);\n}\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\n\n\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to; // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n\n  if (from && from.data) {\n    const hName = from.data.hName;\n    const hChildren = from.data.hChildren;\n    const hProperties = from.data.hProperties;\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName;\n      } // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result];\n        result = {\n          type: 'element',\n          tagName: hName,\n          properties: {},\n          children\n        };\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties));\n    }\n\n    if ('children' in result && result.children && hChildren !== null && hChildren !== undefined) {\n      result.children = hChildren;\n    }\n  }\n\n  return result;\n}\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\n\n\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {};\n  /** @type {HastElement | HastText} */\n\n  const result = 'value' in node && !(own.call(data, 'hProperties') || own.call(data, 'hChildren')) ? {\n    type: 'text',\n    value: node.value\n  } : {\n    type: 'element',\n    tagName: 'div',\n    properties: {},\n    children: state.all(node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\n\n\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = [];\n  let index = -1;\n\n  if (loose) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({\n      type: 'text',\n      value: '\\n'\n    });\n    result.push(nodes[index]);\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n\n  return result;\n}\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\n\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0;\n  let code = value.charCodeAt(index);\n\n  while (code === 9 || code === 32) {\n    index++;\n    code = value.charCodeAt(index);\n  }\n\n  return value.slice(index);\n}","map":{"version":3,"names":["structuredClone","visit","position","handlers","defaultHandlers","own","hasOwnProperty","emptyOptions","createState","tree","options","settings","definitionById","Map","footnoteById","footnoteCounts","state","all","applyData","footnoteOrder","one","patch","wrap","node","type","map","id","String","identifier","toUpperCase","has","set","parent","handle","call","passThrough","includes","children","shallow","result","unknown","unknownHandler","defaultUnknownHandler","values","nodes","index","length","Array","isArray","value","trimMarkdownSpaceStart","head","push","from","to","data","hName","hChildren","hProperties","tagName","properties","Object","assign","undefined","loose","code","charCodeAt","slice"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/mdast-util-to-hast/lib/state.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: '↩'}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the `↩`\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `↩` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {visit} from 'unist-util-visit'\nimport {position} from 'unist-util-position'\nimport {handlers as defaultHandlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map()\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map()\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map()\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {...defaultHandlers, ...settings.handlers}\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  }\n\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById\n      const id = String(node.identifier).toUpperCase()\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node)\n      }\n    }\n  })\n\n  return state\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n  function one(node, parent) {\n    const type = node.type\n    const handle = state.handlers[type]\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent)\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {children, ...shallow} = node\n        const result = structuredClone(shallow)\n        // @ts-expect-error: TS doesn’t understand…\n        result.children = state.all(node)\n        // @ts-expect-error: TS doesn’t understand…\n        return result\n      }\n\n      // @ts-expect-error: it’s custom.\n      return structuredClone(node)\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\n\n    return unknown(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = []\n\n    if ('children' in parent) {\n      const nodes = parent.children\n      let index = -1\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent)\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value)\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0]\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value)\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result)\n          } else {\n            values.push(result)\n          }\n        }\n      }\n    }\n\n    return values\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result]\n        result = {type: 'element', tagName: hName, properties: {}, children}\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties))\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastElement | HastText} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: state.all(node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0\n  let code = value.charCodeAt(index)\n\n  while (code === 9 || code === 32) {\n    index++\n    code = value.charCodeAt(index)\n  }\n\n  return value.slice(index)\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,eAAP,MAA4B,yBAA5B;AACA,SAAQC,KAAR,QAAoB,kBAApB;AACA,SAAQC,QAAR,QAAuB,qBAAvB;AACA,SAAQC,QAAQ,IAAIC,eAApB,QAA0C,qBAA1C;AAEA,MAAMC,GAAG,GAAG,GAAGC,cAAf;AAEA;;AACA,MAAMC,YAAY,GAAG,EAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,OAA3B,EAAoC;EACzC,MAAMC,QAAQ,GAAGD,OAAO,IAAIH,YAA5B;EA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"},"metadata":{},"sourceType":"module"}