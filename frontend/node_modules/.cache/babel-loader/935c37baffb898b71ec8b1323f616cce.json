{"ast":null,"code":"import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\n\nclass NativeAnimation extends WithPromise {\n  constructor(options) {\n    super();\n    this.finishedTime = null;\n    this.isStopped = false;\n    if (!options) return;\n    const {\n      element,\n      name,\n      keyframes,\n      pseudoElement,\n      allowFlatten = false,\n      finalKeyframe,\n      onComplete\n    } = options;\n    this.isPseudoElement = Boolean(pseudoElement);\n    this.allowFlatten = allowFlatten;\n    this.options = options;\n    invariant(typeof options.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"motion\"?`);\n    const transition = applyGeneratorOptions(options);\n    this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n\n    if (transition.autoplay === false) {\n      this.animation.pause();\n    }\n\n    this.animation.onfinish = () => {\n      this.finishedTime = this.time;\n\n      if (!pseudoElement) {\n        const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n\n        if (this.updateMotionValue) {\n          this.updateMotionValue(keyframe);\n        } else {\n          /**\n           * If we can, we want to commit the final style as set by the user,\n           * rather than the computed keyframe value supplied by the animation.\n           */\n          setStyle(element, name, keyframe);\n        }\n\n        this.animation.cancel();\n      }\n\n      onComplete?.();\n      this.notifyFinished();\n    };\n    /**\n     * TODO: In a breaking change, we should replace this with `.notifyCancel()`\n     */\n\n\n    this.animation.oncancel = () => this.notifyFinished();\n  }\n\n  play() {\n    if (this.isStopped) return;\n    this.animation.play();\n\n    if (this.state === \"finished\") {\n      this.updateFinished();\n    }\n  }\n\n  pause() {\n    this.animation.pause();\n  }\n\n  complete() {\n    this.animation.finish?.();\n  }\n\n  cancel() {\n    try {\n      this.animation.cancel();\n    } catch (e) {}\n  }\n\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    const {\n      state\n    } = this;\n\n    if (state === \"idle\" || state === \"finished\") {\n      return;\n    }\n\n    if (this.updateMotionValue) {\n      this.updateMotionValue();\n    } else {\n      this.commitStyles();\n    }\n\n    if (!this.isPseudoElement) this.cancel();\n  }\n  /**\n   * WAAPI doesn't natively have any interruption capabilities.\n   *\n   * In this method, we commit styles back to the DOM before cancelling\n   * the animation.\n   *\n   * This is designed to be overridden by NativeAnimationExtended, which\n   * will create a renderless JS animation and sample it twice to calculate\n   * its current value, \"previous\" value, and therefore allow\n   * Motion to also correctly calculate velocity for any subsequent animation\n   * while deferring the commit until the next animation frame.\n   */\n\n\n  commitStyles() {\n    if (!this.isPseudoElement) {\n      this.animation.commitStyles?.();\n    }\n  }\n\n  get duration() {\n    const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n    return millisecondsToSeconds(Number(duration));\n  }\n\n  get time() {\n    return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n  }\n\n  set time(newTime) {\n    this.finishedTime = null;\n    this.animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  /**\n   * The playback speed of the animation.\n   * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n   */\n\n\n  get speed() {\n    return this.animation.playbackRate;\n  }\n\n  set speed(newSpeed) {\n    // Allow backwards playback after finishing\n    if (newSpeed < 0) this.finishedTime = null;\n    this.animation.playbackRate = newSpeed;\n  }\n\n  get state() {\n    return this.finishedTime !== null ? \"finished\" : this.animation.playState;\n  }\n\n  get startTime() {\n    return Number(this.animation.startTime);\n  }\n\n  set startTime(newStartTime) {\n    this.animation.startTime = newStartTime;\n  }\n  /**\n   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n   */\n\n\n  attachTimeline(_ref) {\n    let {\n      timeline,\n      observe\n    } = _ref;\n\n    if (this.allowFlatten) {\n      this.animation.effect?.updateTiming({\n        easing: \"linear\"\n      });\n    }\n\n    this.animation.onfinish = null;\n\n    if (timeline && supportsScrollTimeline()) {\n      this.animation.timeline = timeline;\n      return noop;\n    } else {\n      return observe(this);\n    }\n  }\n\n}\n\nexport { NativeAnimation };","map":{"version":3,"names":["invariant","millisecondsToSeconds","secondsToMilliseconds","noop","setStyle","supportsScrollTimeline","getFinalKeyframe","WithPromise","startWaapiAnimation","applyGeneratorOptions","NativeAnimation","constructor","options","finishedTime","isStopped","element","name","keyframes","pseudoElement","allowFlatten","finalKeyframe","onComplete","isPseudoElement","Boolean","type","transition","animation","autoplay","pause","onfinish","time","keyframe","speed","updateMotionValue","cancel","notifyFinished","oncancel","play","state","updateFinished","complete","finish","e","stop","commitStyles","duration","effect","getComputedTiming","Number","currentTime","newTime","playbackRate","newSpeed","playState","startTime","newStartTime","attachTimeline","timeline","observe","updateTiming","easing"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs"],"sourcesContent":["import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.finishedTime = null;\n        this.isStopped = false;\n        if (!options)\n            return;\n        const { element, name, keyframes, pseudoElement, allowFlatten = false, finalKeyframe, onComplete, } = options;\n        this.isPseudoElement = Boolean(pseudoElement);\n        this.allowFlatten = allowFlatten;\n        this.options = options;\n        invariant(typeof options.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"motion\"?`);\n        const transition = applyGeneratorOptions(options);\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n        if (transition.autoplay === false) {\n            this.animation.pause();\n        }\n        this.animation.onfinish = () => {\n            this.finishedTime = this.time;\n            if (!pseudoElement) {\n                const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n                if (this.updateMotionValue) {\n                    this.updateMotionValue(keyframe);\n                }\n                else {\n                    /**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */\n                    setStyle(element, name, keyframe);\n                }\n                this.animation.cancel();\n            }\n            onComplete?.();\n            this.notifyFinished();\n        };\n        /**\n         * TODO: In a breaking change, we should replace this with `.notifyCancel()`\n         */\n        this.animation.oncancel = () => this.notifyFinished();\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        this.animation.play();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n        }\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.finish?.();\n    }\n    cancel() {\n        try {\n            this.animation.cancel();\n        }\n        catch (e) { }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        const { state } = this;\n        if (state === \"idle\" || state === \"finished\") {\n            return;\n        }\n        if (this.updateMotionValue) {\n            this.updateMotionValue();\n        }\n        else {\n            this.commitStyles();\n        }\n        if (!this.isPseudoElement)\n            this.cancel();\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    commitStyles() {\n        if (!this.isPseudoElement) {\n            this.animation.commitStyles?.();\n        }\n    }\n    get duration() {\n        const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n        return millisecondsToSeconds(Number(duration));\n    }\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n    }\n    set time(newTime) {\n        this.finishedTime = null;\n        this.animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        // Allow backwards playback after finishing\n        if (newSpeed < 0)\n            this.finishedTime = null;\n        this.animation.playbackRate = newSpeed;\n    }\n    get state() {\n        return this.finishedTime !== null\n            ? \"finished\"\n            : this.animation.playState;\n    }\n    get startTime() {\n        return Number(this.animation.startTime);\n    }\n    set startTime(newStartTime) {\n        this.animation.startTime = newStartTime;\n    }\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }) {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\n        }\n        this.animation.onfinish = null;\n        if (timeline && supportsScrollTimeline()) {\n            this.animation.timeline = timeline;\n            return noop;\n        }\n        else {\n            return observe(this);\n        }\n    }\n}\n\nexport { NativeAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}