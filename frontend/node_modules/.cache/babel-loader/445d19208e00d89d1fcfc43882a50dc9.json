{"ast":null,"code":"import { startWaapiAnimation } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\n\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\n\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\n\nconst suspendedAnimations = new Set();\n\nfunction resumeSuspendedAnimations() {\n  suspendedAnimations.forEach(data => {\n    data.animation.play();\n    data.animation.startTime = data.startTime;\n  });\n  suspendedAnimations.clear();\n}\n\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n  // Prevent optimised appear animations if Motion has already started animating.\n  if (window.MotionIsMounted) {\n    return;\n  }\n\n  const id = element.dataset[optimizedAppearDataId];\n  if (!id) return;\n  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n  const storeId = appearStoreId(id, name);\n\n  if (!readyAnimation) {\n    readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]],\n    /**\n     * 10 secs is basically just a super-safe duration to give Chrome\n     * long enough to get the animation ready.\n     */\n    {\n      duration: 10000,\n      ease: \"linear\"\n    });\n    appearAnimationStore.set(storeId, {\n      animation: readyAnimation,\n      startTime: null\n    });\n    /**\n     * If there's no readyAnimation then there's been no instantiation\n     * of handoff animations.\n     */\n\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n\n    window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n      if (!elementId) return false;\n      /**\n       * Keep a map of elementIds that have started animating. We check\n       * via ID instead of Element because of hydration errors and\n       * pre-hydration checks. We also actively record IDs as they start\n       * animating rather than simply checking for data-appear-id as\n       * this attrbute might be present but not lead to an animation, for\n       * instance if the element's appear animation is on a different\n       * breakpoint.\n       */\n\n      if (!valueName) {\n        return appearComplete.has(elementId);\n      }\n\n      const animationId = appearStoreId(elementId, valueName);\n      return Boolean(appearAnimationStore.get(animationId));\n    };\n\n    window.MotionHandoffMarkAsComplete = elementId => {\n      if (appearComplete.has(elementId)) {\n        appearComplete.set(elementId, true);\n      }\n    };\n\n    window.MotionHandoffIsComplete = elementId => {\n      return appearComplete.get(elementId) === true;\n    };\n    /**\n     * We only need to cancel transform animations as\n     * they're the ones that will interfere with the\n     * layout animation measurements.\n     */\n\n\n    window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n      const animationId = appearStoreId(elementId, valueName);\n      const data = appearAnimationStore.get(animationId);\n      if (!data) return;\n\n      if (frame && canResume === undefined) {\n        /**\n         * Wait until the end of the subsequent frame to cancel the animation\n         * to ensure we don't remove the animation before the main thread has\n         * had a chance to resolve keyframes and render.\n         */\n        frame.postRender(() => {\n          frame.postRender(() => {\n            data.animation.cancel();\n          });\n        });\n      } else {\n        data.animation.cancel();\n      }\n\n      if (frame && canResume) {\n        suspendedAnimations.add(data);\n        frame.render(resumeSuspendedAnimations);\n      } else {\n        appearAnimationStore.delete(animationId);\n        /**\n         * If there are no more animations left, we can remove the cancel function.\n         * This will let us know when we can stop checking for conflicting layout animations.\n         */\n\n        if (!appearAnimationStore.size) {\n          window.MotionCancelOptimisedAnimation = undefined;\n        }\n      }\n    };\n\n    window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n      const appearId = getOptimisedAppearId(visualElement);\n      if (!appearId) return;\n      const valueIsOptimised = window.MotionHasOptimisedAnimation?.(appearId, valueName);\n      const externalAnimationValue = visualElement.props.values?.[valueName];\n      if (!valueIsOptimised || !externalAnimationValue) return;\n      const removeSyncCheck = value.on(\"change\", latestValue => {\n        if (externalAnimationValue.get() !== latestValue) {\n          window.MotionCancelOptimisedAnimation?.(appearId, valueName);\n          removeSyncCheck();\n        }\n      });\n      return removeSyncCheck;\n    };\n  }\n\n  const startAnimation = () => {\n    readyAnimation.cancel();\n    const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n    /**\n     * Record the time of the first started animation. We call performance.now() once\n     * here and once in handoff to ensure we're getting\n     * close to a frame-locked time. This keeps all animations in sync.\n     */\n\n    if (startFrameTime === undefined) {\n      startFrameTime = performance.now();\n    }\n\n    appearAnimation.startTime = startFrameTime;\n    appearAnimationStore.set(storeId, {\n      animation: appearAnimation,\n      startTime: startFrameTime\n    });\n    if (onReady) onReady(appearAnimation);\n  };\n\n  appearComplete.set(id, false);\n\n  if (readyAnimation.ready) {\n    readyAnimation.ready.then(startAnimation).catch(noop);\n  } else {\n    startAnimation();\n  }\n}\n\nexport { startOptimizedAppearAnimation };","map":{"version":3,"names":["startWaapiAnimation","noop","optimizedAppearDataId","getOptimisedAppearId","handoffOptimizedAppearAnimation","appearAnimationStore","appearComplete","appearStoreId","startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionIsMounted","id","dataset","MotionHandoffAnimation","storeId","duration","ease","set","MotionHasOptimisedAnimation","elementId","valueName","has","animationId","Boolean","get","MotionHandoffMarkAsComplete","MotionHandoffIsComplete","MotionCancelOptimisedAnimation","frame","canResume","undefined","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","appearId","valueIsOptimised","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","startAnimation","appearAnimation","performance","now","ready","then","catch"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"sourcesContent":["import { startWaapiAnimation } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data) => {\n        data.animation.play();\n        data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id)\n        return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], \n        /**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */\n        { duration: 10000, ease: \"linear\" });\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null,\n        });\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n            if (!elementId)\n                return false;\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */\n            if (!valueName) {\n                return appearComplete.has(elementId);\n            }\n            const animationId = appearStoreId(elementId, valueName);\n            return Boolean(appearAnimationStore.get(animationId));\n        };\n        window.MotionHandoffMarkAsComplete = (elementId) => {\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true);\n            }\n        };\n        window.MotionHandoffIsComplete = (elementId) => {\n            return appearComplete.get(elementId) === true;\n        };\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n            const animationId = appearStoreId(elementId, valueName);\n            const data = appearAnimationStore.get(animationId);\n            if (!data)\n                return;\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */\n                frame.postRender(() => {\n                    frame.postRender(() => {\n                        data.animation.cancel();\n                    });\n                });\n            }\n            else {\n                data.animation.cancel();\n            }\n            if (frame && canResume) {\n                suspendedAnimations.add(data);\n                frame.render(resumeSuspendedAnimations);\n            }\n            else {\n                appearAnimationStore.delete(animationId);\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */\n                if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined;\n                }\n            }\n        };\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (!appearId)\n                return;\n            const valueIsOptimised = window.MotionHasOptimisedAnimation?.(appearId, valueName);\n            const externalAnimationValue = visualElement.props.values?.[valueName];\n            if (!valueIsOptimised || !externalAnimationValue)\n                return;\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\n                if (externalAnimationValue.get() !== latestValue) {\n                    window.MotionCancelOptimisedAnimation?.(appearId, valueName);\n                    removeSyncCheck();\n                }\n            });\n            return removeSyncCheck;\n        };\n    }\n    const startAnimation = () => {\n        readyAnimation.cancel();\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (startFrameTime === undefined) {\n            startFrameTime = performance.now();\n        }\n        appearAnimation.startTime = startFrameTime;\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime,\n        });\n        if (onReady)\n            onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(noop);\n    }\n    else {\n        startAnimation();\n    }\n}\n\nexport { startOptimizedAppearAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}