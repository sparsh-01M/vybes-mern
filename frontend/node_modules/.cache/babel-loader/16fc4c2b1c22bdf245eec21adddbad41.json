{"ast":null,"code":"/**\n * @import {\n *   Construct,\n *   ContainerState,\n *   InitialConstruct,\n *   Initializer,\n *   Point,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @typedef {[Construct, ContainerState]} StackItem\n *   Construct and its state.\n */\nimport { ok as assert } from 'devlop';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { splice } from 'micromark-util-chunked';\nimport { codes, constants, types } from 'micromark-util-symbol';\n/** @type {InitialConstruct} */\n\nexport const document = {\n  tokenize: initializeDocument\n};\n/** @type {Construct} */\n\nconst containerConstruct = {\n  tokenize: tokenizeContainer\n};\n/**\n * @this {TokenizeContext}\n *   Self.\n * @type {Initializer}\n *   Initializer.\n */\n\nfunction initializeDocument(effects) {\n  const self = this;\n  /** @type {Array<StackItem>} */\n\n  const stack = [];\n  let continued = 0;\n  /** @type {TokenizeContext | undefined} */\n\n  let childFlow;\n  /** @type {Token | undefined} */\n\n  let childToken;\n  /** @type {number} */\n\n  let lineStartOffset;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued];\n      self.containerState = item[1];\n      assert(item[0].continuation, 'expected `continuation` to be defined on container construct');\n      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code);\n    } // Done.\n\n\n    return checkNewContainers(code);\n  }\n  /** @type {State} */\n\n\n  function documentContinue(code) {\n    assert(self.containerState, 'expected `containerState` to be defined after continuation');\n    continued++; // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but it’s already used in the wild by\n    // extensions.\n\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined;\n\n      if (childFlow) {\n        closeFlow();\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n\n\n      const indexBeforeExits = self.events.length;\n      let indexBeforeFlow = indexBeforeExits;\n      /** @type {Point | undefined} */\n\n      let point; // Find the flow chunk.\n\n      while (indexBeforeFlow--) {\n        if (self.events[indexBeforeFlow][0] === 'exit' && self.events[indexBeforeFlow][1].type === types.chunkFlow) {\n          point = self.events[indexBeforeFlow][1].end;\n          break;\n        }\n      }\n\n      assert(point, 'could not find previous flow chunk');\n      exitContainers(continued); // Fix positions.\n\n      let index = indexBeforeExits;\n\n      while (index < self.events.length) {\n        self.events[index][1].end = { ...point\n        };\n        index++;\n      } // Inject the exits earlier (they’re still also at the end).\n\n\n      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits)); // Discard the duplicate exits.\n\n      self.events.length = index;\n      return checkNewContainers(code);\n    }\n\n    return start(code);\n  }\n  /** @type {State} */\n\n\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code);\n      } // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code);\n      } // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n      // To do: next major: remove `_gfmTableDynamicInterruptHack` (no longer\n      // needed in micromark-extension-gfm-table@1.0.6).\n\n\n      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);\n    } // Check if there is a new container.\n\n\n    self.containerState = {};\n    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code);\n  }\n  /** @type {State} */\n\n\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow();\n    exitContainers(continued);\n    return documentContinued(code);\n  }\n  /** @type {State} */\n\n\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length;\n    lineStartOffset = self.now().offset;\n    return flowStart(code);\n  }\n  /** @type {State} */\n\n\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {};\n    return effects.attempt(containerConstruct, containerContinue, flowStart)(code);\n  }\n  /** @type {State} */\n\n\n  function containerContinue(code) {\n    assert(self.currentConstruct, 'expected `currentConstruct` to be defined on tokenizer');\n    assert(self.containerState, 'expected `containerState` to be defined on tokenizer');\n    continued++;\n    stack.push([self.currentConstruct, self.containerState]); // Try another.\n\n    return documentContinued(code);\n  }\n  /** @type {State} */\n\n\n  function flowStart(code) {\n    if (code === codes.eof) {\n      if (childFlow) closeFlow();\n      exitContainers(0);\n      effects.consume(code);\n      return;\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now());\n    effects.enter(types.chunkFlow, {\n      _tokenizer: childFlow,\n      contentType: constants.contentTypeFlow,\n      previous: childToken\n    });\n    return flowContinue(code);\n  }\n  /** @type {State} */\n\n\n  function flowContinue(code) {\n    if (code === codes.eof) {\n      writeToChild(effects.exit(types.chunkFlow), true);\n      exitContainers(0);\n      effects.consume(code);\n      return;\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      writeToChild(effects.exit(types.chunkFlow)); // Get ready for the next line.\n\n      continued = 0;\n      self.interrupt = undefined;\n      return start;\n    }\n\n    effects.consume(code);\n    return flowContinue;\n  }\n  /**\n   * @param {Token} token\n   *   Token.\n   * @param {boolean | undefined} [endOfFile]\n   *   Whether the token is at the end of the file (default: `false`).\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  function writeToChild(token, endOfFile) {\n    assert(childFlow, 'expected `childFlow` to be defined when continuing');\n    const stream = self.sliceStream(token);\n    if (endOfFile) stream.push(null);\n    token.previous = childToken;\n    if (childToken) childToken.next = token;\n    childToken = token;\n    childFlow.defineSkip(token.start);\n    childFlow.write(stream); // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length;\n\n      while (index--) {\n        if ( // The token starts before the line ending…\n        childFlow.events[index][1].start.offset < lineStartOffset && ( // …and either is not ended yet…\n        !childFlow.events[index][1].end || // …or ends after it.\n        childFlow.events[index][1].end.offset > lineStartOffset)) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return;\n        }\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n\n\n      const indexBeforeExits = self.events.length;\n      let indexBeforeFlow = indexBeforeExits;\n      /** @type {boolean | undefined} */\n\n      let seen;\n      /** @type {Point | undefined} */\n\n      let point; // Find the previous chunk (the one before the lazy line).\n\n      while (indexBeforeFlow--) {\n        if (self.events[indexBeforeFlow][0] === 'exit' && self.events[indexBeforeFlow][1].type === types.chunkFlow) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end;\n            break;\n          }\n\n          seen = true;\n        }\n      }\n\n      assert(point, 'could not find previous flow chunk');\n      exitContainers(continued); // Fix positions.\n\n      index = indexBeforeExits;\n\n      while (index < self.events.length) {\n        self.events[index][1].end = { ...point\n        };\n        index++;\n      } // Inject the exits earlier (they’re still also at the end).\n\n\n      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits)); // Discard the duplicate exits.\n\n      self.events.length = index;\n    }\n  }\n  /**\n   * @param {number} size\n   *   Size.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  function exitContainers(size) {\n    let index = stack.length; // Exit open containers.\n\n    while (index-- > size) {\n      const entry = stack[index];\n      self.containerState = entry[1];\n      assert(entry[0].exit, 'expected `exit` to be defined on container construct');\n      entry[0].exit.call(self, effects);\n    }\n\n    stack.length = size;\n  }\n\n  function closeFlow() {\n    assert(self.containerState, 'expected `containerState` to be defined when closing flow');\n    assert(childFlow, 'expected `childFlow` to be defined when closing it');\n    childFlow.write([codes.eof]);\n    childToken = undefined;\n    childFlow = undefined;\n    self.containerState._closeFlow = undefined;\n  }\n}\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n *   Tokenizer.\n */\n\n\nfunction tokenizeContainer(effects, ok, nok) {\n  // Always populated by defaults.\n  assert(this.parser.constructs.disable.null, 'expected `disable.null` to be populated');\n  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok, nok), types.linePrefix, this.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize);\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","splice","codes","constants","types","document","tokenize","initializeDocument","containerConstruct","tokenizeContainer","effects","self","stack","continued","childFlow","childToken","lineStartOffset","start","code","length","item","containerState","continuation","attempt","documentContinue","checkNewContainers","_closeFlow","undefined","closeFlow","indexBeforeExits","events","indexBeforeFlow","point","type","chunkFlow","end","exitContainers","index","slice","documentContinued","currentConstruct","concrete","flowStart","interrupt","Boolean","_gfmTableDynamicInterruptHack","check","thereIsANewContainer","thereIsNoNewContainer","parser","lazy","now","line","offset","containerContinue","push","eof","consume","flow","enter","_tokenizer","contentType","contentTypeFlow","previous","flowContinue","writeToChild","exit","token","endOfFile","stream","sliceStream","next","defineSkip","write","seen","size","entry","call","nok","constructs","disable","null","linePrefix","includes","tabSize"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark/dev/lib/initialize/document.js"],"sourcesContent":["/**\n * @import {\n *   Construct,\n *   ContainerState,\n *   InitialConstruct,\n *   Initializer,\n *   Point,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @typedef {[Construct, ContainerState]} StackItem\n *   Construct and its state.\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {InitialConstruct} */\nexport const document = {tokenize: initializeDocument}\n\n/** @type {Construct} */\nconst containerConstruct = {tokenize: tokenizeContainer}\n\n/**\n * @this {TokenizeContext}\n *   Self.\n * @type {Initializer}\n *   Initializer.\n */\nfunction initializeDocument(effects) {\n  const self = this\n  /** @type {Array<StackItem>} */\n  const stack = []\n  let continued = 0\n  /** @type {TokenizeContext | undefined} */\n  let childFlow\n  /** @type {Token | undefined} */\n  let childToken\n  /** @type {number} */\n  let lineStartOffset\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued]\n      self.containerState = item[1]\n      assert(\n        item[0].continuation,\n        'expected `continuation` to be defined on container construct'\n      )\n      return effects.attempt(\n        item[0].continuation,\n        documentContinue,\n        checkNewContainers\n      )(code)\n    }\n\n    // Done.\n    return checkNewContainers(code)\n  }\n\n  /** @type {State} */\n  function documentContinue(code) {\n    assert(\n      self.containerState,\n      'expected `containerState` to be defined after continuation'\n    )\n\n    continued++\n\n    // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but it’s already used in the wild by\n    // extensions.\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined\n\n      if (childFlow) {\n        closeFlow()\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {Point | undefined} */\n      let point\n\n      // Find the flow chunk.\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === types.chunkFlow\n        ) {\n          point = self.events[indexBeforeFlow][1].end\n          break\n        }\n      }\n\n      assert(point, 'could not find previous flow chunk')\n\n      exitContainers(continued)\n\n      // Fix positions.\n      let index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = {...point}\n        index++\n      }\n\n      // Inject the exits earlier (they’re still also at the end).\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      )\n\n      // Discard the duplicate exits.\n      self.events.length = index\n\n      return checkNewContainers(code)\n    }\n\n    return start(code)\n  }\n\n  /** @type {State} */\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code)\n      }\n\n      // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code)\n      }\n\n      // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n      // To do: next major: remove `_gfmTableDynamicInterruptHack` (no longer\n      // needed in micromark-extension-gfm-table@1.0.6).\n      self.interrupt = Boolean(\n        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack\n      )\n    }\n\n    // Check if there is a new container.\n    self.containerState = {}\n    return effects.check(\n      containerConstruct,\n      thereIsANewContainer,\n      thereIsNoNewContainer\n    )(code)\n  }\n\n  /** @type {State} */\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow()\n    exitContainers(continued)\n    return documentContinued(code)\n  }\n\n  /** @type {State} */\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length\n    lineStartOffset = self.now().offset\n    return flowStart(code)\n  }\n\n  /** @type {State} */\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n\n  /** @type {State} */\n  function containerContinue(code) {\n    assert(\n      self.currentConstruct,\n      'expected `currentConstruct` to be defined on tokenizer'\n    )\n    assert(\n      self.containerState,\n      'expected `containerState` to be defined on tokenizer'\n    )\n    continued++\n    stack.push([self.currentConstruct, self.containerState])\n    // Try another.\n    return documentContinued(code)\n  }\n\n  /** @type {State} */\n  function flowStart(code) {\n    if (code === codes.eof) {\n      if (childFlow) closeFlow()\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter(types.chunkFlow, {\n      _tokenizer: childFlow,\n      contentType: constants.contentTypeFlow,\n      previous: childToken\n    })\n\n    return flowContinue(code)\n  }\n\n  /** @type {State} */\n  function flowContinue(code) {\n    if (code === codes.eof) {\n      writeToChild(effects.exit(types.chunkFlow), true)\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      writeToChild(effects.exit(types.chunkFlow))\n      // Get ready for the next line.\n      continued = 0\n      self.interrupt = undefined\n      return start\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n\n  /**\n   * @param {Token} token\n   *   Token.\n   * @param {boolean | undefined} [endOfFile]\n   *   Whether the token is at the end of the file (default: `false`).\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function writeToChild(token, endOfFile) {\n    assert(childFlow, 'expected `childFlow` to be defined when continuing')\n    const stream = self.sliceStream(token)\n    if (endOfFile) stream.push(null)\n    token.previous = childToken\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.defineSkip(token.start)\n    childFlow.write(stream)\n\n    // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length\n\n      while (index--) {\n        if (\n          // The token starts before the line ending…\n          childFlow.events[index][1].start.offset < lineStartOffset &&\n          // …and either is not ended yet…\n          (!childFlow.events[index][1].end ||\n            // …or ends after it.\n            childFlow.events[index][1].end.offset > lineStartOffset)\n        ) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return\n        }\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {boolean | undefined} */\n      let seen\n      /** @type {Point | undefined} */\n      let point\n\n      // Find the previous chunk (the one before the lazy line).\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === types.chunkFlow\n        ) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end\n            break\n          }\n\n          seen = true\n        }\n      }\n\n      assert(point, 'could not find previous flow chunk')\n\n      exitContainers(continued)\n\n      // Fix positions.\n      index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = {...point}\n        index++\n      }\n\n      // Inject the exits earlier (they’re still also at the end).\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      )\n\n      // Discard the duplicate exits.\n      self.events.length = index\n    }\n  }\n\n  /**\n   * @param {number} size\n   *   Size.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function exitContainers(size) {\n    let index = stack.length\n\n    // Exit open containers.\n    while (index-- > size) {\n      const entry = stack[index]\n      self.containerState = entry[1]\n      assert(\n        entry[0].exit,\n        'expected `exit` to be defined on container construct'\n      )\n      entry[0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function closeFlow() {\n    assert(\n      self.containerState,\n      'expected `containerState` to be defined when closing flow'\n    )\n    assert(childFlow, 'expected `childFlow` to be defined when closing it')\n    childFlow.write([codes.eof])\n    childToken = undefined\n    childFlow = undefined\n    self.containerState._closeFlow = undefined\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n *   Tokenizer.\n */\nfunction tokenizeContainer(effects, ok, nok) {\n  // Always populated by defaults.\n  assert(\n    this.parser.constructs.disable.null,\n    'expected `disable.null` to be populated'\n  )\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    types.linePrefix,\n    this.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : constants.tabSize\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}