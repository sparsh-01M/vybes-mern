{"ast":null,"code":"/**\n * @import {\n *   Code,\n *   InitialConstruct,\n *   Initializer,\n *   Resolver,\n *   State,\n *   TokenizeContext\n * } from 'micromark-util-types'\n */\nimport { ok as assert } from 'devlop';\nimport { codes, constants, types } from 'micromark-util-symbol';\nexport const resolver = {\n  resolveAll: createResolver()\n};\nexport const string = initializeFactory('string');\nexport const text = initializeFactory('text');\n/**\n * @param {'string' | 'text'} field\n *   Field.\n * @returns {InitialConstruct}\n *   Construct.\n */\n\nfunction initializeFactory(field) {\n  return {\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined),\n    tokenize: initializeText\n  };\n  /**\n   * @this {TokenizeContext}\n   *   Context.\n   * @type {Initializer}\n   */\n\n  function initializeText(effects) {\n    const self = this;\n    const constructs = this.parser.constructs[field];\n    const text = effects.attempt(constructs, start, notText);\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n    /** @type {State} */\n\n\n    function notText(code) {\n      if (code === codes.eof) {\n        effects.consume(code);\n        return;\n      }\n\n      effects.enter(types.data);\n      effects.consume(code);\n      return data;\n    }\n    /** @type {State} */\n\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit(types.data);\n        return text(code);\n      } // Data.\n\n\n      effects.consume(code);\n      return data;\n    }\n    /**\n     * @param {Code} code\n     *   Code.\n     * @returns {boolean}\n     *   Whether the code is a break.\n     */\n\n\n    function atBreak(code) {\n      if (code === codes.eof) {\n        return true;\n      }\n\n      const list = constructs[code];\n      let index = -1;\n\n      if (list) {\n        // Always populated by defaults.\n        assert(Array.isArray(list), 'expected `disable.null` to be populated');\n\n        while (++index < list.length) {\n          const item = list[index];\n\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }\n}\n/**\n * @param {Resolver | undefined} [extraResolver]\n *   Resolver.\n * @returns {Resolver}\n *   Resolver.\n */\n\n\nfunction createResolver(extraResolver) {\n  return resolveAllText;\n  /** @type {Resolver} */\n\n  function resolveAllText(events, context) {\n    let index = -1;\n    /** @type {number | undefined} */\n\n    let enter; // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === types.data) {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== types.data) {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n\n        enter = undefined;\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n}\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\n\n\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0; // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {\n      const data = events[eventIndex - 1][1];\n      const chunks = context.sliceStream(data);\n      let index = chunks.length;\n      let bufferIndex = -1;\n      let size = 0;\n      /** @type {boolean | undefined} */\n\n      let tabs;\n\n      while (index--) {\n        const chunk = chunks[index];\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n\n          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {\n            size++;\n            bufferIndex--;\n          }\n\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        } // Number\n        else if (chunk === codes.horizontalTab) {\n          tabs = true;\n          size++;\n        } else if (chunk === codes.virtualSpace) {// Empty\n        } else {\n          // Replacement character, exit.\n          index++;\n          break;\n        }\n      } // Allow final trailing whitespace.\n\n\n      if (context._contentTypeTextTrailing && eventIndex === events.length) {\n        size = 0;\n      }\n\n      if (size) {\n        const token = {\n          type: eventIndex === events.length || tabs || size < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,\n          start: {\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex,\n            _index: data.start._index + index,\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size\n          },\n          end: { ...data.end\n          }\n        };\n        data.end = { ...token.start\n        };\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n\n      eventIndex++;\n    }\n  }\n\n  return events;\n}","map":{"version":3,"names":["ok","assert","codes","constants","types","resolver","resolveAll","createResolver","string","initializeFactory","text","field","resolveAllLineSuffixes","undefined","tokenize","initializeText","effects","self","constructs","parser","attempt","start","notText","code","atBreak","eof","consume","enter","data","exit","list","index","Array","isArray","length","item","previous","call","extraResolver","resolveAllText","events","context","type","end","splice","eventIndex","lineEnding","chunks","sliceStream","bufferIndex","size","tabs","chunk","charCodeAt","space","horizontalTab","virtualSpace","_contentTypeTextTrailing","token","hardBreakPrefixSizeMin","lineSuffix","hardBreakTrailing","_bufferIndex","_index","line","column","offset","Object","assign"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark/dev/lib/initialize/text.js"],"sourcesContent":["/**\n * @import {\n *   Code,\n *   InitialConstruct,\n *   Initializer,\n *   Resolver,\n *   State,\n *   TokenizeContext\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\nexport const resolver = {resolveAll: createResolver()}\nexport const string = initializeFactory('string')\nexport const text = initializeFactory('text')\n\n/**\n * @param {'string' | 'text'} field\n *   Field.\n * @returns {InitialConstruct}\n *   Construct.\n */\nfunction initializeFactory(field) {\n  return {\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    ),\n    tokenize: initializeText\n  }\n\n  /**\n   * @this {TokenizeContext}\n   *   Context.\n   * @type {Initializer}\n   */\n  function initializeText(effects) {\n    const self = this\n    const constructs = this.parser.constructs[field]\n    const text = effects.attempt(constructs, start, notText)\n\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    /** @type {State} */\n    function notText(code) {\n      if (code === codes.eof) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter(types.data)\n      effects.consume(code)\n      return data\n    }\n\n    /** @type {State} */\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit(types.data)\n        return text(code)\n      }\n\n      // Data.\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * @param {Code} code\n     *   Code.\n     * @returns {boolean}\n     *   Whether the code is a break.\n     */\n    function atBreak(code) {\n      if (code === codes.eof) {\n        return true\n      }\n\n      const list = constructs[code]\n      let index = -1\n\n      if (list) {\n        // Always populated by defaults.\n        assert(Array.isArray(list), 'expected `disable.null` to be populated')\n\n        while (++index < list.length) {\n          const item = list[index]\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true\n          }\n        }\n      }\n\n      return false\n    }\n  }\n}\n\n/**\n * @param {Resolver | undefined} [extraResolver]\n *   Resolver.\n * @returns {Resolver}\n *   Resolver.\n */\nfunction createResolver(extraResolver) {\n  return resolveAllText\n\n  /** @type {Resolver} */\n  function resolveAllText(events, context) {\n    let index = -1\n    /** @type {number | undefined} */\n    let enter\n\n    // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === types.data) {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== types.data) {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0 // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === types.lineEnding) &&\n      events[eventIndex - 1][1].type === types.data\n    ) {\n      const data = events[eventIndex - 1][1]\n      const chunks = context.sliceStream(data)\n      let index = chunks.length\n      let bufferIndex = -1\n      let size = 0\n      /** @type {boolean | undefined} */\n      let tabs\n\n      while (index--) {\n        const chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        }\n        // Number\n        else if (chunk === codes.horizontalTab) {\n          tabs = true\n          size++\n        } else if (chunk === codes.virtualSpace) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      // Allow final trailing whitespace.\n      if (context._contentTypeTextTrailing && eventIndex === events.length) {\n        size = 0\n      }\n\n      if (size) {\n        const token = {\n          type:\n            eventIndex === events.length ||\n            tabs ||\n            size < constants.hardBreakPrefixSizeMin\n              ? types.lineSuffix\n              : types.hardBreakTrailing,\n          start: {\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex,\n            _index: data.start._index + index,\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size\n          },\n          end: {...data.end}\n        }\n\n        data.end = {...token.start}\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}