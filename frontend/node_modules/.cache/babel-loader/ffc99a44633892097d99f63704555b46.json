{"ast":null,"code":"import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\n\nconst MAX_RESOLVE_DELAY = 40;\n\nclass AsyncMotionValueAnimation extends WithPromise {\n  constructor(_ref) {\n    let {\n      autoplay = true,\n      delay = 0,\n      type = \"keyframes\",\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType = \"loop\",\n      keyframes,\n      name,\n      motionValue,\n      element,\n      ...options\n    } = _ref;\n    super();\n    /**\n     * Bound to support return animation.stop pattern\n     */\n\n    this.stop = () => {\n      if (this._animation) {\n        this._animation.stop();\n\n        this.stopTimeline?.();\n      } else {\n        this.keyframeResolver?.cancel();\n      }\n    };\n\n    this.createdAt = time.now();\n    const optionsWithDefaults = {\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      name,\n      motionValue,\n      element,\n      ...options\n    };\n    const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n    this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n    this.keyframeResolver?.scheduleResolve();\n  }\n\n  onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n    this.keyframeResolver = undefined;\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      isHandoff,\n      onUpdate\n    } = options;\n    this.resolvedAt = time.now();\n    /**\n     * If we can't animate this value with the resolved keyframes\n     * then we should complete it immediately.\n     */\n\n    if (!canAnimate(keyframes, name, type, velocity)) {\n      if (MotionGlobalConfig.instantAnimations || !delay) {\n        onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n      }\n\n      keyframes[0] = keyframes[keyframes.length - 1];\n      options.duration = 0;\n      options.repeat = 0;\n    }\n    /**\n     * Resolve startTime for the animation.\n     *\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n\n\n    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : undefined;\n    const resolvedOptions = {\n      startTime,\n      finalKeyframe,\n      ...options,\n      keyframes\n    };\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n\n    const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({ ...resolvedOptions,\n      element: resolvedOptions.motionValue.owner.current\n    }) : new JSAnimation(resolvedOptions);\n    animation.finished.then(() => this.notifyFinished()).catch(noop);\n\n    if (this.pendingTimeline) {\n      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n      this.pendingTimeline = undefined;\n    }\n\n    this._animation = animation;\n  }\n\n  get finished() {\n    if (!this._animation) {\n      return this._finished;\n    } else {\n      return this.animation.finished;\n    }\n  }\n\n  then(onResolve, _onReject) {\n    return this.finished.finally(onResolve).then(() => {});\n  }\n\n  get animation() {\n    if (!this._animation) {\n      flushKeyframeResolvers();\n    }\n\n    return this._animation;\n  }\n\n  get duration() {\n    return this.animation.duration;\n  }\n\n  get time() {\n    return this.animation.time;\n  }\n\n  set time(newTime) {\n    this.animation.time = newTime;\n  }\n\n  get speed() {\n    return this.animation.speed;\n  }\n\n  get state() {\n    return this.animation.state;\n  }\n\n  set speed(newSpeed) {\n    this.animation.speed = newSpeed;\n  }\n\n  get startTime() {\n    return this.animation.startTime;\n  }\n\n  attachTimeline(timeline) {\n    if (this._animation) {\n      this.stopTimeline = this.animation.attachTimeline(timeline);\n    } else {\n      this.pendingTimeline = timeline;\n    }\n\n    return () => this.stop();\n  }\n\n  play() {\n    this.animation.play();\n  }\n\n  pause() {\n    this.animation.pause();\n  }\n\n  complete() {\n    this.animation.complete();\n  }\n\n  cancel() {\n    this.animation.cancel();\n  }\n\n}\n\nexport { AsyncMotionValueAnimation };","map":{"version":3,"names":["MotionGlobalConfig","noop","time","JSAnimation","getFinalKeyframe","KeyframeResolver","flushKeyframeResolvers","NativeAnimationExtended","canAnimate","WithPromise","supportsBrowserAnimation","MAX_RESOLVE_DELAY","AsyncMotionValueAnimation","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","keyframes","name","motionValue","element","options","stop","_animation","stopTimeline","keyframeResolver","cancel","createdAt","now","optionsWithDefaults","KeyframeResolver$1","resolvedKeyframes","finalKeyframe","forced","onKeyframesResolved","scheduleResolve","sync","undefined","velocity","isHandoff","onUpdate","resolvedAt","instantAnimations","length","duration","startTime","resolvedOptions","animation","owner","current","finished","then","notifyFinished","catch","pendingTimeline","attachTimeline","_finished","onResolve","_onReject","finally","newTime","speed","state","newSpeed","timeline","play","pause","complete"],"sources":["/Users/sparshsinghal/Downloads/Instagram-mern-stack-main/frontend/node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs"],"sourcesContent":["import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", keyframes, name, motionValue, element, ...options }) {\n        super();\n        /**\n         * Bound to support return animation.stop pattern\n         */\n        this.stop = () => {\n            if (this._animation) {\n                this._animation.stop();\n                this.stopTimeline?.();\n            }\n            else {\n                this.keyframeResolver?.cancel();\n            }\n        };\n        this.createdAt = time.now();\n        const optionsWithDefaults = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        };\n        const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n        this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n        this.keyframeResolver?.scheduleResolve();\n    }\n    onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n        this.keyframeResolver = undefined;\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options;\n        this.resolvedAt = time.now();\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n            }\n            keyframes[0] = keyframes[keyframes.length - 1];\n            options.duration = 0;\n            options.repeat = 0;\n        }\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                    ? this.resolvedAt\n                    : this.createdAt\n            : undefined;\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        };\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n            ? new NativeAnimationExtended({\n                ...resolvedOptions,\n                element: resolvedOptions.motionValue.owner.current,\n            })\n            : new JSAnimation(resolvedOptions);\n        animation.finished.then(() => this.notifyFinished()).catch(noop);\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        this._animation = animation;\n    }\n    get finished() {\n        if (!this._animation) {\n            return this._finished;\n        }\n        else {\n            return this.animation.finished;\n        }\n    }\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n    get animation() {\n        if (!this._animation) {\n            flushKeyframeResolvers();\n        }\n        return this._animation;\n    }\n    get duration() {\n        return this.animation.duration;\n    }\n    get time() {\n        return this.animation.time;\n    }\n    set time(newTime) {\n        this.animation.time = newTime;\n    }\n    get speed() {\n        return this.animation.speed;\n    }\n    get state() {\n        return this.animation.state;\n    }\n    set speed(newSpeed) {\n        this.animation.speed = newSpeed;\n    }\n    get startTime() {\n        return this.animation.startTime;\n    }\n    attachTimeline(timeline) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline);\n        }\n        else {\n            this.pendingTimeline = timeline;\n        }\n        return () => this.stop();\n    }\n    play() {\n        this.animation.play();\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.complete();\n    }\n    cancel() {\n        this.animation.cancel();\n    }\n}\n\nexport { AsyncMotionValueAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}