{"ast":null,"code":"import { VOID, PRIMITIVE, ARRAY, OBJECT, DATE, REGEXP, MAP, SET, ERROR, BIGINT } from './types.js';\nconst EMPTY = '';\nconst {\n  toString\n} = {};\nconst {\n  keys\n} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value) return [PRIMITIVE, type];\n  const asString = toString.call(value).slice(8, -1);\n\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n\n    case 'Object':\n      return [OBJECT, EMPTY];\n\n    case 'Date':\n      return [DATE, EMPTY];\n\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n\n    case 'Map':\n      return [MAP, EMPTY];\n\n    case 'Set':\n      return [SET, EMPTY];\n\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n\n  if (asString.includes('Array')) return [ARRAY, asString];\n  if (asString.includes('Error')) return [ERROR, asString];\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = _ref => {\n  let [TYPE, type] = _ref;\n  return TYPE === PRIMITIVE && (type === 'function' || type === 'symbol');\n};\n\nconst serializer = (strict, json, $, _) => {\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value)) return $.get(value);\n    let [TYPE, type] = typeOf(value);\n\n    switch (TYPE) {\n      case PRIMITIVE:\n        {\n          let entry = value;\n\n          switch (type) {\n            case 'bigint':\n              TYPE = BIGINT;\n              entry = value.toString();\n              break;\n\n            case 'function':\n            case 'symbol':\n              if (strict) throw new TypeError('unable to serialize ' + type);\n              entry = null;\n              break;\n\n            case 'undefined':\n              return as([VOID], value);\n          }\n\n          return as([TYPE, entry], value);\n        }\n\n      case ARRAY:\n        {\n          if (type) {\n            let spread = value;\n\n            if (type === 'DataView') {\n              spread = new Uint8Array(value.buffer);\n            } else if (type === 'ArrayBuffer') {\n              spread = new Uint8Array(value);\n            }\n\n            return as([type, [...spread]], value);\n          }\n\n          const arr = [];\n          const index = as([TYPE, arr], value);\n\n          for (const entry of value) arr.push(pair(entry));\n\n          return index;\n        }\n\n      case OBJECT:\n        {\n          if (type) {\n            switch (type) {\n              case 'BigInt':\n                return as([type, value.toString()], value);\n\n              case 'Boolean':\n              case 'Number':\n              case 'String':\n                return as([type, value.valueOf()], value);\n            }\n          }\n\n          if (json && 'toJSON' in value) return pair(value.toJSON());\n          const entries = [];\n          const index = as([TYPE, entries], value);\n\n          for (const key of keys(value)) {\n            if (strict || !shouldSkip(typeOf(value[key]))) entries.push([pair(key), pair(value[key])]);\n          }\n\n          return index;\n        }\n\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n\n      case REGEXP:\n        {\n          const {\n            source,\n            flags\n          } = value;\n          return as([TYPE, {\n            source,\n            flags\n          }], value);\n        }\n\n      case MAP:\n        {\n          const entries = [];\n          const index = as([TYPE, entries], value);\n\n          for (const [key, entry] of value) {\n            if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry)))) entries.push([pair(key), pair(entry)]);\n          }\n\n          return index;\n        }\n\n      case SET:\n        {\n          const entries = [];\n          const index = as([TYPE, entries], value);\n\n          for (const entry of value) {\n            if (strict || !shouldSkip(typeOf(entry))) entries.push(pair(entry));\n          }\n\n          return index;\n        }\n    }\n\n    const {\n      message\n    } = value;\n    return as([TYPE, {\n      name: type,\n      message\n    }], value);\n  };\n\n  return pair;\n};\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n\n\nexport const serialize = function (value) {\n  let {\n    json,\n    lossy\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map(), _)(value), _;\n};","map":{"version":3,"names":["VOID","PRIMITIVE","ARRAY","OBJECT","DATE","REGEXP","MAP","SET","ERROR","BIGINT","EMPTY","toString","keys","Object","typeOf","value","type","asString","call","slice","includes","shouldSkip","TYPE","serializer","strict","json","$","_","as","out","index","push","set","pair","has","get","entry","TypeError","spread","Uint8Array","buffer","arr","valueOf","toJSON","entries","key","toISOString","source","flags","message","name","serialize","lossy","Map"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/@ungap/structured-clone/esm/serialize.js"],"sourcesContent":["import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type) {\n          let spread = value;\n          if (type === 'DataView') {\n            spread = new Uint8Array(value.buffer);\n          }\n          else if (type === 'ArrayBuffer') {\n            spread = new Uint8Array(value);\n          }\n          return as([type, [...spread]], value);\n        }\n\n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}