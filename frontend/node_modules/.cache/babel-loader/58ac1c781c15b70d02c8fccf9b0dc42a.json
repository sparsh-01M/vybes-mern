{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is = // Note: overloads in JSDoc can’t yet use different `@template`s.\n\n/**\n * @type {(\n *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n *   ((node?: null | undefined) => false) &\n *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n * )}\n */\n\n/**\n * @param {unknown} [node]\n * @param {Test} [test]\n * @param {number | null | undefined} [index]\n * @param {Parent | null | undefined} [parent]\n * @param {unknown} [context]\n * @returns {boolean}\n */\n// eslint-disable-next-line max-params\nfunction (node, test, index, parent, context) {\n  const check = convert(test);\n\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index');\n  }\n\n  if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  }\n\n  return looksLikeANode(node) ? check.call(context, node, index, parent) : false;\n};\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\n\nexport const convert = // Note: overloads in JSDoc can’t yet use different `@template`s.\n\n/**\n * @type {(\n *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n *   ((test?: Test) => Check)\n * )}\n */\n\n/**\n * @param {Test} [test]\n * @returns {Check}\n */\nfunction (test) {\n  if (test === null || test === undefined) {\n    return ok;\n  }\n\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n\n  if (typeof test === 'object') {\n    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\n  }\n\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n\n  throw new Error('Expected function, string, or object as test');\n};\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\n\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = [];\n  let index = -1;\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index]);\n  }\n\n  return castFactory(any);\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n\n  function any() {\n    let index = -1;\n\n    for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      parameters[_key] = arguments[_key];\n    }\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true;\n    }\n\n    return false;\n  }\n}\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\n\n\nfunction propsFactory(check) {\n  const checkAsRecord =\n  /** @type {Record<string, unknown>} */\n  check;\n  return castFactory(all);\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n\n  function all(node) {\n    const nodeAsRecord =\n    /** @type {Record<string, unknown>} */\n\n    /** @type {unknown} */\n    node;\n    /** @type {string} */\n\n    let key;\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;\n    }\n\n    return true;\n  }\n}\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\n\n\nfunction typeFactory(check) {\n  return castFactory(type);\n  /**\n   * @param {Node} node\n   */\n\n  function type(node) {\n    return node && node.type === check;\n  }\n}\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\n\n\nfunction castFactory(testFunction) {\n  return check;\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n\n  function check(value, index, parent) {\n    return Boolean(looksLikeANode(value) && testFunction.call(this, value, typeof index === 'number' ? index : undefined, parent || undefined));\n  }\n}\n\nfunction ok() {\n  return true;\n}\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\n\n\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value;\n}","map":{"version":3,"names":["is","node","test","index","parent","context","check","convert","undefined","Number","POSITIVE_INFINITY","Error","children","looksLikeANode","call","ok","castFactory","Array","isArray","anyFactory","propsFactory","typeFactory","tests","checks","length","any","parameters","apply","checkAsRecord","all","nodeAsRecord","key","type","testFunction","value","Boolean"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/unist-util-is/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,EAAE,GACb;;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA,UAAUC,IAAV,EAAgBC,IAAhB,EAAsBC,KAAtB,EAA6BC,MAA7B,EAAqCC,OAArC,EAA8C;EAC5C,MAAMC,KAAK,GAAGC,OAAO,CAACL,IAAD,CAArB;;EAEA,IACEC,KAAK,KAAKK,SAAV,IACAL,KAAK,KAAK,IADV,KAEC,OAAOA,KAAP,KAAiB,QAAjB,IACCA,KAAK,GAAG,CADT,IAECA,KAAK,KAAKM,MAAM,CAACC,iBAJnB,CADF,EAME;IACA,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;EACD;;EAED,IACEP,MAAM,KAAKI,SAAX,IACAJ,MAAM,KAAK,IADX,KAEC,CAACJ,EAAE,CAACI,MAAD,CAAH,IAAe,CAACA,MAAM,CAACQ,QAFxB,CADF,EAIE;IACA,MAAM,IAAID,KAAJ,CAAU,sBAAV,CAAN;EACD;;EAED,IACE,CAACP,MAAM,KAAKI,SAAX,IAAwBJ,MAAM,KAAK,IAApC,OACCD,KAAK,KAAKK,SAAV,IAAuBL,KAAK,KAAK,IADlC,CADF,EAGE;IACA,MAAM,IAAIQ,KAAJ,CAAU,gCAAV,CAAN;EACD;;EAED,OAAOE,cAAc,CAACZ,IAAD,CAAd,GACHK,KAAK,CAACQ,IAAN,CAAWT,OAAX,EAAoBJ,IAApB,EAA0BE,KAA1B,EAAiCC,MAAjC,CADG,GAEH,KAFJ;AAGD,CArDE;AAwDP;AACA;AACA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"},"metadata":{},"sourceType":"module"}