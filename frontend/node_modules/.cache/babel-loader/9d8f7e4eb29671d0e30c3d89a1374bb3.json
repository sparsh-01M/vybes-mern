{"ast":null,"code":"import { constants } from 'micromark-util-symbol';\n/**\n * Some of the internal operations of micromark do lots of editing\n * operations on very large arrays. This runs into problems with two\n * properties of most circa-2020 JavaScript interpreters:\n *\n *  - Array-length modifications at the high end of an array (push/pop) are\n *    expected to be common and are implemented in (amortized) time\n *    proportional to the number of elements added or removed, whereas\n *    other operations (shift/unshift and splice) are much less efficient.\n *  - Function arguments are passed on the stack, so adding tens of thousands\n *    of elements to an array with `arr.push(...newElements)` will frequently\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\n *\n * SpliceBuffers are an implementation of gap buffers, which are a\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\n * maintains a cursor, and moving the cursor has cost proportional to the\n * distance the cursor moves, but inserting, deleting, or splicing in\n * new information at the cursor is as efficient as the push/pop operation.\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\n * or unshifts) as long such edits happen at the same part of the array or\n * generally sweep through the array from the beginning to the end.\n *\n * The interface for splice buffers also supports large numbers of inputs by\n * passing a single array argument rather passing multiple arguments on the\n * function call stack.\n *\n * @template T\n *   Item type.\n */\n\nexport class SpliceBuffer {\n  /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */\n  constructor(initial) {\n    /** @type {Array<T>} */\n    this.left = initial ? [...initial] : [];\n    /** @type {Array<T>} */\n\n    this.right = [];\n  }\n  /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */\n\n\n  get(index) {\n    if (index < 0 || index >= this.left.length + this.right.length) {\n      throw new RangeError('Cannot access index `' + index + '` in a splice buffer of size `' + (this.left.length + this.right.length) + '`');\n    }\n\n    if (index < this.left.length) return this.left[index];\n    return this.right[this.right.length - index + this.left.length - 1];\n  }\n  /**\n   * The length of the splice buffer, one greater than the largest index in the\n   * array.\n   */\n\n\n  get length() {\n    return this.left.length + this.right.length;\n  }\n  /**\n   * Remove and return `list[0]`;\n   * moves the cursor to `0`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n\n\n  shift() {\n    this.setCursor(0);\n    return this.right.pop();\n  }\n  /**\n   * Slice the buffer to get an array;\n   * does not move the cursor.\n   *\n   * @param {number} start\n   *   Start.\n   * @param {number | null | undefined} [end]\n   *   End (optional).\n   * @returns {Array<T>}\n   *   Array of items.\n   */\n\n\n  slice(start, end) {\n    /** @type {number} */\n    const stop = end === null || end === undefined ? Number.POSITIVE_INFINITY : end;\n\n    if (stop < this.left.length) {\n      return this.left.slice(start, stop);\n    }\n\n    if (start > this.left.length) {\n      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();\n    }\n\n    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());\n  }\n  /**\n   * Mimics the behavior of Array.prototype.splice() except for the change of\n   * interface necessary to avoid segfaults when patching in very large arrays.\n   *\n   * This operation moves cursor is moved to `start` and results in the cursor\n   * placed after any inserted items.\n   *\n   * @param {number} start\n   *   Start;\n   *   zero-based index at which to start changing the array;\n   *   negative numbers count backwards from the end of the array and values\n   *   that are out-of bounds are clamped to the appropriate end of the array.\n   * @param {number | null | undefined} [deleteCount=0]\n   *   Delete count (default: `0`);\n   *   maximum number of elements to delete, starting from start.\n   * @param {Array<T> | null | undefined} [items=[]]\n   *   Items to include in place of the deleted items (default: `[]`).\n   * @return {Array<T>}\n   *   Any removed items.\n   */\n\n\n  splice(start, deleteCount, items) {\n    /** @type {number} */\n    const count = deleteCount || 0;\n    this.setCursor(Math.trunc(start));\n    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);\n    if (items) chunkedPush(this.left, items);\n    return removed.reverse();\n  }\n  /**\n   * Remove and return the highest-numbered item in the array, so\n   * `list[list.length - 1]`;\n   * Moves the cursor to `length`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n\n\n  pop() {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    return this.left.pop();\n  }\n  /**\n   * Inserts a single item to the high-numbered side of the array;\n   * moves the cursor to `length`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  push(item) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    this.left.push(item);\n  }\n  /**\n   * Inserts many items to the high-numbered side of the array.\n   * Moves the cursor to `length`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  pushMany(items) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    chunkedPush(this.left, items);\n  }\n  /**\n   * Inserts a single item to the low-numbered side of the array;\n   * Moves the cursor to `0`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  unshift(item) {\n    this.setCursor(0);\n    this.right.push(item);\n  }\n  /**\n   * Inserts many items to the low-numbered side of the array;\n   * moves the cursor to `0`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  unshiftMany(items) {\n    this.setCursor(0);\n    chunkedPush(this.right, items.reverse());\n  }\n  /**\n   * Move the cursor to a specific position in the array. Requires\n   * time proportional to the distance moved.\n   *\n   * If `n < 0`, the cursor will end up at the beginning.\n   * If `n > length`, the cursor will end up at the end.\n   *\n   * @param {number} n\n   *   Position.\n   * @return {undefined}\n   *   Nothing.\n   */\n\n\n  setCursor(n) {\n    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;\n\n    if (n < this.left.length) {\n      // Move cursor to the this.left\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.right, removed.reverse());\n    } else {\n      // Move cursor to the this.right\n      const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.left, removed.reverse());\n    }\n  }\n\n}\n/**\n * Avoid stack overflow by pushing items onto the stack in segments\n *\n * @template T\n *   Item type.\n * @param {Array<T>} list\n *   List to inject into.\n * @param {ReadonlyArray<T>} right\n *   Items to inject.\n * @return {undefined}\n *   Nothing.\n */\n\nfunction chunkedPush(list, right) {\n  /** @type {number} */\n  let chunkStart = 0;\n\n  if (right.length < constants.v8MaxSafeChunkSize) {\n    list.push(...right);\n  } else {\n    while (chunkStart < right.length) {\n      list.push(...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize));\n      chunkStart += constants.v8MaxSafeChunkSize;\n    }\n  }\n}","map":{"version":3,"names":["constants","SpliceBuffer","constructor","initial","left","right","get","index","length","RangeError","shift","setCursor","pop","slice","start","end","stop","undefined","Number","POSITIVE_INFINITY","reverse","concat","splice","deleteCount","items","count","Math","trunc","removed","chunkedPush","push","item","pushMany","unshift","unshiftMany","n","list","chunkStart","v8MaxSafeChunkSize"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js"],"sourcesContent":["import {constants} from 'micromark-util-symbol'\n\n/**\n * Some of the internal operations of micromark do lots of editing\n * operations on very large arrays. This runs into problems with two\n * properties of most circa-2020 JavaScript interpreters:\n *\n *  - Array-length modifications at the high end of an array (push/pop) are\n *    expected to be common and are implemented in (amortized) time\n *    proportional to the number of elements added or removed, whereas\n *    other operations (shift/unshift and splice) are much less efficient.\n *  - Function arguments are passed on the stack, so adding tens of thousands\n *    of elements to an array with `arr.push(...newElements)` will frequently\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\n *\n * SpliceBuffers are an implementation of gap buffers, which are a\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\n * maintains a cursor, and moving the cursor has cost proportional to the\n * distance the cursor moves, but inserting, deleting, or splicing in\n * new information at the cursor is as efficient as the push/pop operation.\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\n * or unshifts) as long such edits happen at the same part of the array or\n * generally sweep through the array from the beginning to the end.\n *\n * The interface for splice buffers also supports large numbers of inputs by\n * passing a single array argument rather passing multiple arguments on the\n * function call stack.\n *\n * @template T\n *   Item type.\n */\nexport class SpliceBuffer {\n  /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */\n  constructor(initial) {\n    /** @type {Array<T>} */\n    this.left = initial ? [...initial] : []\n    /** @type {Array<T>} */\n    this.right = []\n  }\n\n  /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */\n  get(index) {\n    if (index < 0 || index >= this.left.length + this.right.length) {\n      throw new RangeError(\n        'Cannot access index `' +\n          index +\n          '` in a splice buffer of size `' +\n          (this.left.length + this.right.length) +\n          '`'\n      )\n    }\n\n    if (index < this.left.length) return this.left[index]\n    return this.right[this.right.length - index + this.left.length - 1]\n  }\n\n  /**\n   * The length of the splice buffer, one greater than the largest index in the\n   * array.\n   */\n  get length() {\n    return this.left.length + this.right.length\n  }\n\n  /**\n   * Remove and return `list[0]`;\n   * moves the cursor to `0`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  shift() {\n    this.setCursor(0)\n    return this.right.pop()\n  }\n\n  /**\n   * Slice the buffer to get an array;\n   * does not move the cursor.\n   *\n   * @param {number} start\n   *   Start.\n   * @param {number | null | undefined} [end]\n   *   End (optional).\n   * @returns {Array<T>}\n   *   Array of items.\n   */\n  slice(start, end) {\n    /** @type {number} */\n    const stop =\n      end === null || end === undefined ? Number.POSITIVE_INFINITY : end\n\n    if (stop < this.left.length) {\n      return this.left.slice(start, stop)\n    }\n\n    if (start > this.left.length) {\n      return this.right\n        .slice(\n          this.right.length - stop + this.left.length,\n          this.right.length - start + this.left.length\n        )\n        .reverse()\n    }\n\n    return this.left\n      .slice(start)\n      .concat(\n        this.right.slice(this.right.length - stop + this.left.length).reverse()\n      )\n  }\n\n  /**\n   * Mimics the behavior of Array.prototype.splice() except for the change of\n   * interface necessary to avoid segfaults when patching in very large arrays.\n   *\n   * This operation moves cursor is moved to `start` and results in the cursor\n   * placed after any inserted items.\n   *\n   * @param {number} start\n   *   Start;\n   *   zero-based index at which to start changing the array;\n   *   negative numbers count backwards from the end of the array and values\n   *   that are out-of bounds are clamped to the appropriate end of the array.\n   * @param {number | null | undefined} [deleteCount=0]\n   *   Delete count (default: `0`);\n   *   maximum number of elements to delete, starting from start.\n   * @param {Array<T> | null | undefined} [items=[]]\n   *   Items to include in place of the deleted items (default: `[]`).\n   * @return {Array<T>}\n   *   Any removed items.\n   */\n  splice(start, deleteCount, items) {\n    /** @type {number} */\n    const count = deleteCount || 0\n\n    this.setCursor(Math.trunc(start))\n    const removed = this.right.splice(\n      this.right.length - count,\n      Number.POSITIVE_INFINITY\n    )\n    if (items) chunkedPush(this.left, items)\n    return removed.reverse()\n  }\n\n  /**\n   * Remove and return the highest-numbered item in the array, so\n   * `list[list.length - 1]`;\n   * Moves the cursor to `length`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  pop() {\n    this.setCursor(Number.POSITIVE_INFINITY)\n    return this.left.pop()\n  }\n\n  /**\n   * Inserts a single item to the high-numbered side of the array;\n   * moves the cursor to `length`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  push(item) {\n    this.setCursor(Number.POSITIVE_INFINITY)\n    this.left.push(item)\n  }\n\n  /**\n   * Inserts many items to the high-numbered side of the array.\n   * Moves the cursor to `length`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  pushMany(items) {\n    this.setCursor(Number.POSITIVE_INFINITY)\n    chunkedPush(this.left, items)\n  }\n\n  /**\n   * Inserts a single item to the low-numbered side of the array;\n   * Moves the cursor to `0`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshift(item) {\n    this.setCursor(0)\n    this.right.push(item)\n  }\n\n  /**\n   * Inserts many items to the low-numbered side of the array;\n   * moves the cursor to `0`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshiftMany(items) {\n    this.setCursor(0)\n    chunkedPush(this.right, items.reverse())\n  }\n\n  /**\n   * Move the cursor to a specific position in the array. Requires\n   * time proportional to the distance moved.\n   *\n   * If `n < 0`, the cursor will end up at the beginning.\n   * If `n > length`, the cursor will end up at the end.\n   *\n   * @param {number} n\n   *   Position.\n   * @return {undefined}\n   *   Nothing.\n   */\n  setCursor(n) {\n    if (\n      n === this.left.length ||\n      (n > this.left.length && this.right.length === 0) ||\n      (n < 0 && this.left.length === 0)\n    )\n      return\n    if (n < this.left.length) {\n      // Move cursor to the this.left\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY)\n      chunkedPush(this.right, removed.reverse())\n    } else {\n      // Move cursor to the this.right\n      const removed = this.right.splice(\n        this.left.length + this.right.length - n,\n        Number.POSITIVE_INFINITY\n      )\n      chunkedPush(this.left, removed.reverse())\n    }\n  }\n}\n\n/**\n * Avoid stack overflow by pushing items onto the stack in segments\n *\n * @template T\n *   Item type.\n * @param {Array<T>} list\n *   List to inject into.\n * @param {ReadonlyArray<T>} right\n *   Items to inject.\n * @return {undefined}\n *   Nothing.\n */\nfunction chunkedPush(list, right) {\n  /** @type {number} */\n  let chunkStart = 0\n\n  if (right.length < constants.v8MaxSafeChunkSize) {\n    list.push(...right)\n  } else {\n    while (chunkStart < right.length) {\n      list.push(\n        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)\n      )\n      chunkStart += constants.v8MaxSafeChunkSize\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}