{"ast":null,"code":"/**\n * While micromark is a lexer/tokenizer, the common case of going from markdown\n * to html is currently built in as this module, even though the parts can be\n * used separately to build ASTs, CSTs, or many other output formats.\n *\n * Having an HTML compiler built in is useful because it allows us to check for\n * compliancy to CommonMark, the de facto norm of markdown, specified in roughly\n * 600 input/output cases.\n *\n * This module has an interface that accepts lists of events instead of the\n * whole at once, however, because markdown can’t be truly streaming, we buffer\n * events before processing and outputting the final result.\n */\n\n/**\n * @import {\n *   CompileContext,\n *   CompileData,\n *   CompileOptions,\n *   Compile,\n *   Definition,\n *   Event,\n *   Handle,\n *   HtmlExtension,\n *   LineEnding,\n *   NormalizedHtmlExtension,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @typedef Media\n * @property {boolean | undefined} [image]\n * @property {string | undefined} [labelId]\n * @property {string | undefined} [label]\n * @property {string | undefined} [referenceId]\n * @property {string | undefined} [destination]\n * @property {string | undefined} [title]\n */\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { ok as assert } from 'devlop';\nimport { push } from 'micromark-util-chunked';\nimport { combineHtmlExtensions } from 'micromark-util-combine-extensions';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { encode as _encode } from 'micromark-util-encode';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { sanitizeUri } from 'micromark-util-sanitize-uri';\nimport { codes, constants, types } from 'micromark-util-symbol';\nconst hasOwnProperty = {}.hasOwnProperty;\n/**\n * These two are allowlists of safe protocols for full URLs in respectively the\n * `href` (on `<a>`) and `src` (on `<img>`) attributes.\n * They are based on what is allowed on GitHub,\n * <https://github.com/syntax-tree/hast-util-sanitize/blob/9275b21/lib/github.json#L31>\n */\n\nconst protocolHref = /^(https?|ircs?|mailto|xmpp)$/i;\nconst protocolSource = /^https?$/i;\n/**\n * @param {CompileOptions | null | undefined} [options]\n * @returns {Compile}\n */\n\nexport function compile(options) {\n  const settings = options || {};\n  /**\n   * Tags is needed because according to markdown, links and emphasis and\n   * whatnot can exist in images, however, as HTML doesn’t allow content in\n   * images, the tags are ignored in the `alt` attribute, but the content\n   * remains.\n   *\n   * @type {boolean | undefined}\n   */\n\n  let tags = true;\n  /**\n   * An object to track identifiers to media (URLs and titles) defined with\n   * definitions.\n   *\n   * @type {Record<string, Definition>}\n   */\n\n  const definitions = {};\n  /**\n   * A lot of the handlers need to capture some of the output data, modify it\n   * somehow, and then deal with it.\n   * We do that by tracking a stack of buffers, that can be opened (with\n   * `buffer`) and closed (with `resume`) to access them.\n   *\n   * @type {Array<Array<string>>}\n   */\n\n  const buffers = [[]];\n  /**\n   * As we can have links in images and the other way around, where the deepest\n   * ones are closed first, we need to track which one we’re in.\n   *\n   * @type {Array<Media>}\n   */\n\n  const mediaStack = [];\n  /**\n   * Same as `mediaStack` for tightness, which is specific to lists.\n   * We need to track if we’re currently in a tight or loose container.\n   *\n   * @type {Array<boolean>}\n   */\n\n  const tightStack = [];\n  /** @type {HtmlExtension} */\n\n  const defaultHandlers = {\n    enter: {\n      blockQuote: onenterblockquote,\n      codeFenced: onentercodefenced,\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: onentercodeindented,\n      codeText: onentercodetext,\n      content: onentercontent,\n      definition: onenterdefinition,\n      definitionDestinationString: onenterdefinitiondestinationstring,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: onenteremphasis,\n      htmlFlow: onenterhtmlflow,\n      htmlText: onenterhtml,\n      image: onenterimage,\n      label: buffer,\n      link: onenterlink,\n      listItemMarker: onenterlistitemmarker,\n      listItemValue: onenterlistitemvalue,\n      listOrdered: onenterlistordered,\n      listUnordered: onenterlistunordered,\n      paragraph: onenterparagraph,\n      reference: buffer,\n      resource: onenterresource,\n      resourceDestinationString: onenterresourcedestinationstring,\n      resourceTitleString: buffer,\n      setextHeading: onentersetextheading,\n      strong: onenterstrong\n    },\n    exit: {\n      atxHeading: onexitatxheading,\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: onexitblockquote,\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: onexitflowcode,\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onresumedrop,\n      codeFlowValue: onexitcodeflowvalue,\n      codeIndented: onexitflowcode,\n      codeText: onexitcodetext,\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: onexitdefinition,\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: onexitemphasis,\n      hardBreakEscape: onexithardbreak,\n      hardBreakTrailing: onexithardbreak,\n      htmlFlow: onexithtml,\n      htmlFlowData: onexitdata,\n      htmlText: onexithtml,\n      htmlTextData: onexitdata,\n      image: onexitmedia,\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: onexitmedia,\n      listOrdered: onexitlistordered,\n      listUnordered: onexitlistunordered,\n      paragraph: onexitparagraph,\n      reference: onresumedrop,\n      referenceString: onexitreferencestring,\n      resource: onresumedrop,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      setextHeading: onexitsetextheading,\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: onexitstrong,\n      thematicBreak: onexitthematicbreak\n    }\n  };\n  /**\n   * Combine the HTML extensions with the default handlers.\n   * An HTML extension is an object whose fields are either `enter` or `exit`\n   * (reflecting whether a token is entered or exited).\n   * The values at such objects are names of tokens mapping to handlers.\n   * Handlers are called, respectively when a token is opener or closed, with\n   * that token, and a context as `this`.\n   */\n\n  const handlers =\n  /** @type {NormalizedHtmlExtension} */\n  combineHtmlExtensions([defaultHandlers, ...(settings.htmlExtensions || [])]);\n  /**\n   * Handlers do often need to keep track of some state.\n   * That state is provided here as a key-value store (an object).\n   *\n   * @type {CompileData}\n   */\n\n  const data = {\n    definitions,\n    tightStack\n  };\n  /**\n   * The context for handlers references a couple of useful functions.\n   * In handlers from extensions, those can be accessed at `this`.\n   * For the handlers here, they can be accessed directly.\n   *\n   * @type {Omit<CompileContext, 'sliceSerialize'>}\n   */\n\n  const context = {\n    buffer,\n    encode,\n    getData,\n    lineEndingIfNeeded,\n    options: settings,\n    raw,\n    resume,\n    setData,\n    tag\n  };\n  /**\n   * Generally, micromark copies line endings (`'\\r'`, `'\\n'`, `'\\r\\n'`) in the\n   * markdown document over to the compiled HTML.\n   * In some cases, such as `> a`, CommonMark requires that extra line endings\n   * are added: `<blockquote>\\n<p>a</p>\\n</blockquote>`.\n   * This variable hold the default line ending when given (or `undefined`),\n   * and in the latter case will be updated to the first found line ending if\n   * there is one.\n   */\n\n  let lineEndingStyle = settings.defaultLineEnding; // Return the function that handles a slice of events.\n\n  return compile;\n  /**\n   * Deal w/ a slice of events.\n   * Return either the empty string if there’s nothing of note to return, or the\n   * result when done.\n   *\n   * @param {ReadonlyArray<Event>} events\n   * @returns {string}\n   */\n\n  function compile(events) {\n    let index = -1;\n    let start = 0;\n    /** @type {Array<number>} */\n\n    const listStack = []; // As definitions can come after references, we need to figure out the media\n    // (urls and titles) defined by them before handling the references.\n    // So, we do sort of what HTML does: put metadata at the start (in head), and\n    // then put content after (`body`).\n\n    /** @type {Array<Event>} */\n\n    let head = [];\n    /** @type {Array<Event>} */\n\n    let body = [];\n\n    while (++index < events.length) {\n      // Figure out the line ending style used in the document.\n      if (!lineEndingStyle && (events[index][1].type === types.lineEnding || events[index][1].type === types.lineEndingBlank)) {\n        lineEndingStyle =\n        /** @type {LineEnding} */\n        events[index][2].sliceSerialize(events[index][1]);\n      } // Preprocess lists to infer whether the list is loose or not.\n\n\n      if (events[index][1].type === types.listOrdered || events[index][1].type === types.listUnordered) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          prepareList(events.slice(listStack.pop(), index));\n        }\n      } // Move definitions to the front.\n\n\n      if (events[index][1].type === types.definition) {\n        if (events[index][0] === 'enter') {\n          body = push(body, events.slice(start, index));\n          start = index;\n        } else {\n          head = push(head, events.slice(start, index + 1));\n          start = index + 1;\n        }\n      }\n    }\n\n    head = push(head, body);\n    head = push(head, events.slice(start));\n    index = -1;\n    const result = head; // Handle the start of the document, if defined.\n\n    if (handlers.enter.null) {\n      handlers.enter.null.call(context);\n    } // Handle all events.\n\n\n    while (++index < events.length) {\n      const handles = handlers[result[index][0]];\n      const kind = result[index][1].type;\n      const handle = handles[kind];\n\n      if (hasOwnProperty.call(handles, kind) && handle) {\n        handle.call({\n          sliceSerialize: result[index][2].sliceSerialize,\n          ...context\n        }, result[index][1]);\n      }\n    } // Handle the end of the document, if defined.\n\n\n    if (handlers.exit.null) {\n      handlers.exit.null.call(context);\n    }\n\n    return buffers[0].join('');\n  }\n  /**\n   * Figure out whether lists are loose or not.\n   *\n   * @param {ReadonlyArray<Event>} slice\n   * @returns {undefined}\n   */\n\n\n  function prepareList(slice) {\n    const length = slice.length;\n    let index = 0; // Skip open.\n\n    let containerBalance = 0;\n    let loose = false;\n    /** @type {boolean | undefined} */\n\n    let atMarker;\n\n    while (++index < length) {\n      const event = slice[index];\n\n      if (event[1]._container) {\n        atMarker = undefined;\n\n        if (event[0] === 'enter') {\n          containerBalance++;\n        } else {\n          containerBalance--;\n        }\n      } else switch (event[1].type) {\n        case types.listItemPrefix:\n          {\n            if (event[0] === 'exit') {\n              atMarker = true;\n            }\n\n            break;\n          }\n\n        case types.linePrefix:\n          {\n            // Ignore\n            break;\n          }\n\n        case types.lineEndingBlank:\n          {\n            if (event[0] === 'enter' && !containerBalance) {\n              if (atMarker) {\n                atMarker = undefined;\n              } else {\n                loose = true;\n              }\n            }\n\n            break;\n          }\n\n        default:\n          {\n            atMarker = undefined;\n          }\n      }\n    }\n\n    slice[0][1]._loose = loose;\n  }\n  /**\n   * @type {CompileContext['setData']}\n   */\n\n\n  function setData(key, value) {\n    // @ts-expect-error: assume `value` is omitted (`undefined` is passed) only\n    // if allowed.\n    data[key] = value;\n  }\n  /**\n   * @type {CompileContext['getData']}\n   */\n\n\n  function getData(key) {\n    return data[key];\n  }\n  /** @type {CompileContext['buffer']} */\n\n\n  function buffer() {\n    buffers.push([]);\n  }\n  /** @type {CompileContext['resume']} */\n\n\n  function resume() {\n    const buf = buffers.pop();\n    assert(buf !== undefined, 'Cannot resume w/o buffer');\n    return buf.join('');\n  }\n  /** @type {CompileContext['tag']} */\n\n\n  function tag(value) {\n    if (!tags) return;\n    setData('lastWasTag', true);\n    buffers[buffers.length - 1].push(value);\n  }\n  /** @type {CompileContext['raw']} */\n\n\n  function raw(value) {\n    setData('lastWasTag');\n    buffers[buffers.length - 1].push(value);\n  }\n  /**\n   * Output an extra line ending.\n   *\n   * @returns {undefined}\n   */\n\n\n  function lineEnding() {\n    raw(lineEndingStyle || '\\n');\n  }\n  /** @type {CompileContext['lineEndingIfNeeded']} */\n\n\n  function lineEndingIfNeeded() {\n    const buffer = buffers[buffers.length - 1];\n    const slice = buffer[buffer.length - 1];\n    const previous = slice ? slice.charCodeAt(slice.length - 1) : codes.eof;\n\n    if (previous === codes.lf || previous === codes.cr || previous === codes.eof) {\n      return;\n    }\n\n    lineEnding();\n  }\n  /** @type {CompileContext['encode']} */\n\n\n  function encode(value) {\n    return getData('ignoreEncode') ? value : _encode(value);\n  } //\n  // Handlers.\n  //\n\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onresumedrop() {\n    resume();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistordered(token) {\n    tightStack.push(!token._loose);\n    lineEndingIfNeeded();\n    tag('<ol');\n    setData('expectFirstItem', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistunordered(token) {\n    tightStack.push(!token._loose);\n    lineEndingIfNeeded();\n    tag('<ul');\n    setData('expectFirstItem', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectFirstItem')) {\n      const value = Number.parseInt(this.sliceSerialize(token), constants.numericBaseDecimal);\n\n      if (value !== 1) {\n        tag(' start=\"' + encode(String(value)) + '\"');\n      }\n    }\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onenterlistitemmarker() {\n    if (getData('expectFirstItem')) {\n      tag('>');\n    } else {\n      onexitlistitem();\n    }\n\n    lineEndingIfNeeded();\n    tag('<li>');\n    setData('expectFirstItem'); // “Hack” to prevent a line ending from showing up if the item is empty.\n\n    setData('lastWasTag');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onexitlistordered() {\n    onexitlistitem();\n    tightStack.pop();\n    lineEnding();\n    tag('</ol>');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onexitlistunordered() {\n    onexitlistitem();\n    tightStack.pop();\n    lineEnding();\n    tag('</ul>');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onexitlistitem() {\n    if (getData('lastWasTag') && !getData('slurpAllLineEndings')) {\n      lineEndingIfNeeded();\n    }\n\n    tag('</li>');\n    setData('slurpAllLineEndings');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterblockquote() {\n    tightStack.push(false);\n    lineEndingIfNeeded();\n    tag('<blockquote>');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitblockquote() {\n    tightStack.pop();\n    lineEndingIfNeeded();\n    tag('</blockquote>');\n    setData('slurpAllLineEndings');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterparagraph() {\n    if (!tightStack[tightStack.length - 1]) {\n      lineEndingIfNeeded();\n      tag('<p>');\n    }\n\n    setData('slurpAllLineEndings');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitparagraph() {\n    if (tightStack[tightStack.length - 1]) {\n      setData('slurpAllLineEndings', true);\n    } else {\n      tag('</p>');\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onentercodefenced() {\n    lineEndingIfNeeded();\n    tag('<pre><code');\n    setData('fencesCount', 0);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfenceinfo() {\n    const value = resume();\n    tag(' class=\"language-' + value + '\"');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfence() {\n    const count = getData('fencesCount') || 0;\n\n    if (!count) {\n      tag('>');\n      setData('slurpOneLineEnding', true);\n    }\n\n    setData('fencesCount', count + 1);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onentercodeindented() {\n    lineEndingIfNeeded();\n    tag('<pre><code>');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitflowcode() {\n    const count = getData('fencesCount'); // One special case is if we are inside a container, and the fenced code was\n    // not closed (meaning it runs to the end).\n    // In that case, the following line ending, is considered *outside* the\n    // fenced code and block quote by micromark, but CM wants to treat that\n    // ending as part of the code.\n\n    if (count !== undefined && count < 2 && data.tightStack.length > 0 && !getData('lastWasTag')) {\n      lineEnding();\n    } // But in most cases, it’s simpler: when we’ve seen some data, emit an extra\n    // line ending when needed.\n\n\n    if (getData('flowCodeSeenData')) {\n      lineEndingIfNeeded();\n    }\n\n    tag('</code></pre>');\n    if (count !== undefined && count < 2) lineEndingIfNeeded();\n    setData('flowCodeSeenData');\n    setData('fencesCount');\n    setData('slurpOneLineEnding');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterimage() {\n    mediaStack.push({\n      image: true\n    });\n    tags = undefined; // Disallow tags.\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlink() {\n    mediaStack.push({});\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlabeltext(token) {\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlabel() {\n    mediaStack[mediaStack.length - 1].label = resume();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitreferencestring(token) {\n    mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterresource() {\n    buffer(); // We can have line endings in the resource, ignore them.\n\n    mediaStack[mediaStack.length - 1].destination = '';\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterresourcedestinationstring() {\n    buffer(); // Ignore encoding the result, as we’ll first percent encode the url and\n    // encode manually after.\n\n    setData('ignoreEncode', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresourcedestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume();\n    setData('ignoreEncode');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresourcetitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitmedia() {\n    let index = mediaStack.length - 1; // Skip current.\n\n    const media = mediaStack[index];\n    const id = media.referenceId || media.labelId;\n    assert(id !== undefined, 'media should have `referenceId` or `labelId`');\n    assert(media.label !== undefined, 'media should have `label`');\n    const context = media.destination === undefined ? definitions[normalizeIdentifier(id)] : media;\n    tags = true;\n\n    while (index--) {\n      if (mediaStack[index].image) {\n        tags = undefined;\n        break;\n      }\n    }\n\n    if (media.image) {\n      tag('<img src=\"' + sanitizeUri(context.destination, settings.allowDangerousProtocol ? undefined : protocolSource) + '\" alt=\"');\n      raw(media.label);\n      tag('\"');\n    } else {\n      tag('<a href=\"' + sanitizeUri(context.destination, settings.allowDangerousProtocol ? undefined : protocolHref) + '\"');\n    }\n\n    tag(context.title ? ' title=\"' + context.title + '\"' : '');\n\n    if (media.image) {\n      tag(' />');\n    } else {\n      tag('>');\n      raw(media.label);\n      tag('</a>');\n    }\n\n    mediaStack.pop();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterdefinition() {\n    buffer();\n    mediaStack.push({});\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    resume();\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterdefinitiondestinationstring() {\n    buffer();\n    setData('ignoreEncode', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitiondestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume();\n    setData('ignoreEncode');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitiontitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinition() {\n    const media = mediaStack[mediaStack.length - 1];\n    assert(media.labelId !== undefined, 'media should have `labelId`');\n    const id = normalizeIdentifier(media.labelId);\n    resume();\n\n    if (!hasOwnProperty.call(definitions, id)) {\n      definitions[id] = mediaStack[mediaStack.length - 1];\n    }\n\n    mediaStack.pop();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onentercontent() {\n    setData('slurpAllLineEndings', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitatxheadingsequence(token) {\n    // Exit for further sequences.\n    if (getData('headingRank')) return;\n    setData('headingRank', this.sliceSerialize(token).length);\n    lineEndingIfNeeded();\n    tag('<h' + getData('headingRank') + '>');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onentersetextheading() {\n    buffer();\n    setData('slurpAllLineEndings');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheadingtext() {\n    setData('slurpAllLineEndings', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitatxheading() {\n    tag('</h' + getData('headingRank') + '>');\n    setData('headingRank');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheadinglinesequence(token) {\n    setData('headingRank', this.sliceSerialize(token).charCodeAt(0) === codes.equalsTo ? 1 : 2);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheading() {\n    const value = resume();\n    lineEndingIfNeeded();\n    tag('<h' + getData('headingRank') + '>');\n    raw(value);\n    tag('</h' + getData('headingRank') + '>');\n    setData('slurpAllLineEndings');\n    setData('headingRank');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdata(token) {\n    raw(encode(this.sliceSerialize(token)));\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlineending(token) {\n    if (getData('slurpAllLineEndings')) {\n      return;\n    }\n\n    if (getData('slurpOneLineEnding')) {\n      setData('slurpOneLineEnding');\n      return;\n    }\n\n    if (getData('inCodeText')) {\n      raw(' ');\n      return;\n    }\n\n    raw(encode(this.sliceSerialize(token)));\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodeflowvalue(token) {\n    raw(encode(this.sliceSerialize(token)));\n    setData('flowCodeSeenData', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithardbreak() {\n    tag('<br />');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onenterhtmlflow() {\n    lineEndingIfNeeded();\n    onenterhtml();\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onexithtml() {\n    setData('ignoreEncode');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onenterhtml() {\n    if (settings.allowDangerousHtml) {\n      setData('ignoreEncode', true);\n    }\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onenteremphasis() {\n    tag('<em>');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onenterstrong() {\n    tag('<strong>');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onentercodetext() {\n    setData('inCodeText', true);\n    tag('<code>');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onexitcodetext() {\n    setData('inCodeText');\n    tag('</code>');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onexitemphasis() {\n    tag('</em>');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onexitstrong() {\n    tag('</strong>');\n  }\n  /**\n   * @returns {undefined}\n   */\n\n\n  function onexitthematicbreak() {\n    lineEndingIfNeeded();\n    tag('<hr />');\n  }\n  /**\n   * @this {CompileContext}\n   * @param {Token} token\n   * @returns {undefined}\n   */\n\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcharacterreferencevalue(token) {\n    const value = this.sliceSerialize(token);\n    const decoded = getData('characterReferenceType') ? decodeNumericCharacterReference(value, getData('characterReferenceType') === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal) : decodeNamedCharacterReference(value); // `decodeNamedCharacterReference` can return `false` for invalid named\n    // character references,\n    // but everything we’ve tokenized is valid.\n\n    raw(encode(\n    /** @type {string} */\n    decoded));\n    setData('characterReferenceType');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitautolinkprotocol(token) {\n    const uri = this.sliceSerialize(token);\n    tag('<a href=\"' + sanitizeUri(uri, settings.allowDangerousProtocol ? undefined : protocolHref) + '\">');\n    raw(encode(uri));\n    tag('</a>');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitautolinkemail(token) {\n    const uri = this.sliceSerialize(token);\n    tag('<a href=\"' + sanitizeUri('mailto:' + uri) + '\">');\n    raw(encode(uri));\n    tag('</a>');\n  }\n}","map":{"version":3,"names":["decodeNamedCharacterReference","ok","assert","push","combineHtmlExtensions","decodeNumericCharacterReference","encode","_encode","normalizeIdentifier","sanitizeUri","codes","constants","types","hasOwnProperty","protocolHref","protocolSource","compile","options","settings","tags","definitions","buffers","mediaStack","tightStack","defaultHandlers","enter","blockQuote","onenterblockquote","codeFenced","onentercodefenced","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","onentercodeindented","codeText","onentercodetext","content","onentercontent","definition","onenterdefinition","definitionDestinationString","onenterdefinitiondestinationstring","definitionLabelString","definitionTitleString","emphasis","onenteremphasis","htmlFlow","onenterhtmlflow","htmlText","onenterhtml","image","onenterimage","label","link","onenterlink","listItemMarker","onenterlistitemmarker","listItemValue","onenterlistitemvalue","listOrdered","onenterlistordered","listUnordered","onenterlistunordered","paragraph","onenterparagraph","reference","resource","onenterresource","resourceDestinationString","onenterresourcedestinationstring","resourceTitleString","setextHeading","onentersetextheading","strong","onenterstrong","exit","atxHeading","onexitatxheading","atxHeadingSequence","onexitatxheadingsequence","autolinkEmail","onexitautolinkemail","autolinkProtocol","onexitautolinkprotocol","onexitblockquote","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitflowcode","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onresumedrop","codeFlowValue","onexitcodeflowvalue","onexitcodetext","codeTextData","data","onexitdefinition","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexitemphasis","hardBreakEscape","onexithardbreak","hardBreakTrailing","onexithtml","htmlFlowData","htmlTextData","onexitmedia","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlistordered","onexitlistunordered","onexitparagraph","referenceString","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","onexitstrong","thematicBreak","onexitthematicbreak","handlers","htmlExtensions","context","getData","lineEndingIfNeeded","raw","resume","setData","tag","lineEndingStyle","defaultLineEnding","events","index","start","listStack","head","body","length","type","lineEndingBlank","sliceSerialize","prepareList","slice","pop","result","null","call","handles","kind","handle","join","containerBalance","loose","atMarker","event","_container","undefined","listItemPrefix","linePrefix","_loose","key","value","buf","previous","charCodeAt","eof","lf","cr","token","Number","parseInt","numericBaseDecimal","String","onexitlistitem","count","labelId","referenceId","destination","title","media","id","allowDangerousProtocol","equalsTo","allowDangerousHtml","decoded","numericBaseHexadecimal","uri"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark/dev/lib/compile.js"],"sourcesContent":["/**\n * While micromark is a lexer/tokenizer, the common case of going from markdown\n * to html is currently built in as this module, even though the parts can be\n * used separately to build ASTs, CSTs, or many other output formats.\n *\n * Having an HTML compiler built in is useful because it allows us to check for\n * compliancy to CommonMark, the de facto norm of markdown, specified in roughly\n * 600 input/output cases.\n *\n * This module has an interface that accepts lists of events instead of the\n * whole at once, however, because markdown can’t be truly streaming, we buffer\n * events before processing and outputting the final result.\n */\n\n/**\n * @import {\n *   CompileContext,\n *   CompileData,\n *   CompileOptions,\n *   Compile,\n *   Definition,\n *   Event,\n *   Handle,\n *   HtmlExtension,\n *   LineEnding,\n *   NormalizedHtmlExtension,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @typedef Media\n * @property {boolean | undefined} [image]\n * @property {string | undefined} [labelId]\n * @property {string | undefined} [label]\n * @property {string | undefined} [referenceId]\n * @property {string | undefined} [destination]\n * @property {string | undefined} [title]\n */\n\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {ok as assert} from 'devlop'\nimport {push} from 'micromark-util-chunked'\nimport {combineHtmlExtensions} from 'micromark-util-combine-extensions'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {encode as _encode} from 'micromark-util-encode'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * These two are allowlists of safe protocols for full URLs in respectively the\n * `href` (on `<a>`) and `src` (on `<img>`) attributes.\n * They are based on what is allowed on GitHub,\n * <https://github.com/syntax-tree/hast-util-sanitize/blob/9275b21/lib/github.json#L31>\n */\nconst protocolHref = /^(https?|ircs?|mailto|xmpp)$/i\nconst protocolSource = /^https?$/i\n\n/**\n * @param {CompileOptions | null | undefined} [options]\n * @returns {Compile}\n */\nexport function compile(options) {\n  const settings = options || {}\n\n  /**\n   * Tags is needed because according to markdown, links and emphasis and\n   * whatnot can exist in images, however, as HTML doesn’t allow content in\n   * images, the tags are ignored in the `alt` attribute, but the content\n   * remains.\n   *\n   * @type {boolean | undefined}\n   */\n  let tags = true\n\n  /**\n   * An object to track identifiers to media (URLs and titles) defined with\n   * definitions.\n   *\n   * @type {Record<string, Definition>}\n   */\n  const definitions = {}\n\n  /**\n   * A lot of the handlers need to capture some of the output data, modify it\n   * somehow, and then deal with it.\n   * We do that by tracking a stack of buffers, that can be opened (with\n   * `buffer`) and closed (with `resume`) to access them.\n   *\n   * @type {Array<Array<string>>}\n   */\n  const buffers = [[]]\n\n  /**\n   * As we can have links in images and the other way around, where the deepest\n   * ones are closed first, we need to track which one we’re in.\n   *\n   * @type {Array<Media>}\n   */\n  const mediaStack = []\n\n  /**\n   * Same as `mediaStack` for tightness, which is specific to lists.\n   * We need to track if we’re currently in a tight or loose container.\n   *\n   * @type {Array<boolean>}\n   */\n  const tightStack = []\n\n  /** @type {HtmlExtension} */\n  const defaultHandlers = {\n    enter: {\n      blockQuote: onenterblockquote,\n      codeFenced: onentercodefenced,\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: onentercodeindented,\n      codeText: onentercodetext,\n      content: onentercontent,\n      definition: onenterdefinition,\n      definitionDestinationString: onenterdefinitiondestinationstring,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: onenteremphasis,\n      htmlFlow: onenterhtmlflow,\n      htmlText: onenterhtml,\n      image: onenterimage,\n      label: buffer,\n      link: onenterlink,\n      listItemMarker: onenterlistitemmarker,\n      listItemValue: onenterlistitemvalue,\n      listOrdered: onenterlistordered,\n      listUnordered: onenterlistunordered,\n      paragraph: onenterparagraph,\n      reference: buffer,\n      resource: onenterresource,\n      resourceDestinationString: onenterresourcedestinationstring,\n      resourceTitleString: buffer,\n      setextHeading: onentersetextheading,\n      strong: onenterstrong\n    },\n    exit: {\n      atxHeading: onexitatxheading,\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: onexitblockquote,\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: onexitflowcode,\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onresumedrop,\n      codeFlowValue: onexitcodeflowvalue,\n      codeIndented: onexitflowcode,\n      codeText: onexitcodetext,\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: onexitdefinition,\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: onexitemphasis,\n      hardBreakEscape: onexithardbreak,\n      hardBreakTrailing: onexithardbreak,\n      htmlFlow: onexithtml,\n      htmlFlowData: onexitdata,\n      htmlText: onexithtml,\n      htmlTextData: onexitdata,\n      image: onexitmedia,\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: onexitmedia,\n      listOrdered: onexitlistordered,\n      listUnordered: onexitlistunordered,\n      paragraph: onexitparagraph,\n      reference: onresumedrop,\n      referenceString: onexitreferencestring,\n      resource: onresumedrop,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      setextHeading: onexitsetextheading,\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: onexitstrong,\n      thematicBreak: onexitthematicbreak\n    }\n  }\n\n  /**\n   * Combine the HTML extensions with the default handlers.\n   * An HTML extension is an object whose fields are either `enter` or `exit`\n   * (reflecting whether a token is entered or exited).\n   * The values at such objects are names of tokens mapping to handlers.\n   * Handlers are called, respectively when a token is opener or closed, with\n   * that token, and a context as `this`.\n   */\n  const handlers = /** @type {NormalizedHtmlExtension} */ (\n    combineHtmlExtensions([defaultHandlers, ...(settings.htmlExtensions || [])])\n  )\n\n  /**\n   * Handlers do often need to keep track of some state.\n   * That state is provided here as a key-value store (an object).\n   *\n   * @type {CompileData}\n   */\n  const data = {\n    definitions,\n    tightStack\n  }\n\n  /**\n   * The context for handlers references a couple of useful functions.\n   * In handlers from extensions, those can be accessed at `this`.\n   * For the handlers here, they can be accessed directly.\n   *\n   * @type {Omit<CompileContext, 'sliceSerialize'>}\n   */\n  const context = {\n    buffer,\n    encode,\n    getData,\n    lineEndingIfNeeded,\n    options: settings,\n    raw,\n    resume,\n    setData,\n    tag\n  }\n\n  /**\n   * Generally, micromark copies line endings (`'\\r'`, `'\\n'`, `'\\r\\n'`) in the\n   * markdown document over to the compiled HTML.\n   * In some cases, such as `> a`, CommonMark requires that extra line endings\n   * are added: `<blockquote>\\n<p>a</p>\\n</blockquote>`.\n   * This variable hold the default line ending when given (or `undefined`),\n   * and in the latter case will be updated to the first found line ending if\n   * there is one.\n   */\n  let lineEndingStyle = settings.defaultLineEnding\n\n  // Return the function that handles a slice of events.\n  return compile\n\n  /**\n   * Deal w/ a slice of events.\n   * Return either the empty string if there’s nothing of note to return, or the\n   * result when done.\n   *\n   * @param {ReadonlyArray<Event>} events\n   * @returns {string}\n   */\n  function compile(events) {\n    let index = -1\n    let start = 0\n    /** @type {Array<number>} */\n    const listStack = []\n    // As definitions can come after references, we need to figure out the media\n    // (urls and titles) defined by them before handling the references.\n    // So, we do sort of what HTML does: put metadata at the start (in head), and\n    // then put content after (`body`).\n    /** @type {Array<Event>} */\n    let head = []\n    /** @type {Array<Event>} */\n    let body = []\n\n    while (++index < events.length) {\n      // Figure out the line ending style used in the document.\n      if (\n        !lineEndingStyle &&\n        (events[index][1].type === types.lineEnding ||\n          events[index][1].type === types.lineEndingBlank)\n      ) {\n        lineEndingStyle = /** @type {LineEnding} */ (\n          events[index][2].sliceSerialize(events[index][1])\n        )\n      }\n\n      // Preprocess lists to infer whether the list is loose or not.\n      if (\n        events[index][1].type === types.listOrdered ||\n        events[index][1].type === types.listUnordered\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          prepareList(events.slice(listStack.pop(), index))\n        }\n      }\n\n      // Move definitions to the front.\n      if (events[index][1].type === types.definition) {\n        if (events[index][0] === 'enter') {\n          body = push(body, events.slice(start, index))\n          start = index\n        } else {\n          head = push(head, events.slice(start, index + 1))\n          start = index + 1\n        }\n      }\n    }\n\n    head = push(head, body)\n    head = push(head, events.slice(start))\n    index = -1\n    const result = head\n\n    // Handle the start of the document, if defined.\n    if (handlers.enter.null) {\n      handlers.enter.null.call(context)\n    }\n\n    // Handle all events.\n    while (++index < events.length) {\n      const handles = handlers[result[index][0]]\n      const kind = result[index][1].type\n      const handle = handles[kind]\n\n      if (hasOwnProperty.call(handles, kind) && handle) {\n        handle.call(\n          {sliceSerialize: result[index][2].sliceSerialize, ...context},\n          result[index][1]\n        )\n      }\n    }\n\n    // Handle the end of the document, if defined.\n    if (handlers.exit.null) {\n      handlers.exit.null.call(context)\n    }\n\n    return buffers[0].join('')\n  }\n\n  /**\n   * Figure out whether lists are loose or not.\n   *\n   * @param {ReadonlyArray<Event>} slice\n   * @returns {undefined}\n   */\n  function prepareList(slice) {\n    const length = slice.length\n    let index = 0 // Skip open.\n    let containerBalance = 0\n    let loose = false\n    /** @type {boolean | undefined} */\n    let atMarker\n\n    while (++index < length) {\n      const event = slice[index]\n\n      if (event[1]._container) {\n        atMarker = undefined\n\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n      } else\n        switch (event[1].type) {\n          case types.listItemPrefix: {\n            if (event[0] === 'exit') {\n              atMarker = true\n            }\n\n            break\n          }\n\n          case types.linePrefix: {\n            // Ignore\n\n            break\n          }\n\n          case types.lineEndingBlank: {\n            if (event[0] === 'enter' && !containerBalance) {\n              if (atMarker) {\n                atMarker = undefined\n              } else {\n                loose = true\n              }\n            }\n\n            break\n          }\n\n          default: {\n            atMarker = undefined\n          }\n        }\n    }\n\n    slice[0][1]._loose = loose\n  }\n\n  /**\n   * @type {CompileContext['setData']}\n   */\n  function setData(key, value) {\n    // @ts-expect-error: assume `value` is omitted (`undefined` is passed) only\n    // if allowed.\n    data[key] = value\n  }\n\n  /**\n   * @type {CompileContext['getData']}\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /** @type {CompileContext['buffer']} */\n  function buffer() {\n    buffers.push([])\n  }\n\n  /** @type {CompileContext['resume']} */\n  function resume() {\n    const buf = buffers.pop()\n    assert(buf !== undefined, 'Cannot resume w/o buffer')\n    return buf.join('')\n  }\n\n  /** @type {CompileContext['tag']} */\n  function tag(value) {\n    if (!tags) return\n    setData('lastWasTag', true)\n    buffers[buffers.length - 1].push(value)\n  }\n\n  /** @type {CompileContext['raw']} */\n  function raw(value) {\n    setData('lastWasTag')\n    buffers[buffers.length - 1].push(value)\n  }\n\n  /**\n   * Output an extra line ending.\n   *\n   * @returns {undefined}\n   */\n  function lineEnding() {\n    raw(lineEndingStyle || '\\n')\n  }\n\n  /** @type {CompileContext['lineEndingIfNeeded']} */\n  function lineEndingIfNeeded() {\n    const buffer = buffers[buffers.length - 1]\n    const slice = buffer[buffer.length - 1]\n    const previous = slice ? slice.charCodeAt(slice.length - 1) : codes.eof\n\n    if (\n      previous === codes.lf ||\n      previous === codes.cr ||\n      previous === codes.eof\n    ) {\n      return\n    }\n\n    lineEnding()\n  }\n\n  /** @type {CompileContext['encode']} */\n  function encode(value) {\n    return getData('ignoreEncode') ? value : _encode(value)\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @returns {undefined}\n   */\n  function onresumedrop() {\n    resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered(token) {\n    tightStack.push(!token._loose)\n    lineEndingIfNeeded()\n    tag('<ol')\n    setData('expectFirstItem', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistunordered(token) {\n    tightStack.push(!token._loose)\n    lineEndingIfNeeded()\n    tag('<ul')\n    setData('expectFirstItem', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectFirstItem')) {\n      const value = Number.parseInt(\n        this.sliceSerialize(token),\n        constants.numericBaseDecimal\n      )\n\n      if (value !== 1) {\n        tag(' start=\"' + encode(String(value)) + '\"')\n      }\n    }\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterlistitemmarker() {\n    if (getData('expectFirstItem')) {\n      tag('>')\n    } else {\n      onexitlistitem()\n    }\n\n    lineEndingIfNeeded()\n    tag('<li>')\n    setData('expectFirstItem')\n    // “Hack” to prevent a line ending from showing up if the item is empty.\n    setData('lastWasTag')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistordered() {\n    onexitlistitem()\n    tightStack.pop()\n    lineEnding()\n    tag('</ol>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistunordered() {\n    onexitlistitem()\n    tightStack.pop()\n    lineEnding()\n    tag('</ul>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistitem() {\n    if (getData('lastWasTag') && !getData('slurpAllLineEndings')) {\n      lineEndingIfNeeded()\n    }\n\n    tag('</li>')\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterblockquote() {\n    tightStack.push(false)\n    lineEndingIfNeeded()\n    tag('<blockquote>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitblockquote() {\n    tightStack.pop()\n    lineEndingIfNeeded()\n    tag('</blockquote>')\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterparagraph() {\n    if (!tightStack[tightStack.length - 1]) {\n      lineEndingIfNeeded()\n      tag('<p>')\n    }\n\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitparagraph() {\n    if (tightStack[tightStack.length - 1]) {\n      setData('slurpAllLineEndings', true)\n    } else {\n      tag('</p>')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercodefenced() {\n    lineEndingIfNeeded()\n    tag('<pre><code')\n    setData('fencesCount', 0)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const value = resume()\n    tag(' class=\"language-' + value + '\"')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    const count = getData('fencesCount') || 0\n\n    if (!count) {\n      tag('>')\n      setData('slurpOneLineEnding', true)\n    }\n\n    setData('fencesCount', count + 1)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercodeindented() {\n    lineEndingIfNeeded()\n    tag('<pre><code>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitflowcode() {\n    const count = getData('fencesCount')\n\n    // One special case is if we are inside a container, and the fenced code was\n    // not closed (meaning it runs to the end).\n    // In that case, the following line ending, is considered *outside* the\n    // fenced code and block quote by micromark, but CM wants to treat that\n    // ending as part of the code.\n    if (\n      count !== undefined &&\n      count < 2 &&\n      data.tightStack.length > 0 &&\n      !getData('lastWasTag')\n    ) {\n      lineEnding()\n    }\n\n    // But in most cases, it’s simpler: when we’ve seen some data, emit an extra\n    // line ending when needed.\n    if (getData('flowCodeSeenData')) {\n      lineEndingIfNeeded()\n    }\n\n    tag('</code></pre>')\n    if (count !== undefined && count < 2) lineEndingIfNeeded()\n    setData('flowCodeSeenData')\n    setData('fencesCount')\n    setData('slurpOneLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterimage() {\n    mediaStack.push({image: true})\n    tags = undefined // Disallow tags.\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlink() {\n    mediaStack.push({})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlabeltext(token) {\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlabel() {\n    mediaStack[mediaStack.length - 1].label = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitreferencestring(token) {\n    mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterresource() {\n    buffer() // We can have line endings in the resource, ignore them.\n    mediaStack[mediaStack.length - 1].destination = ''\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterresourcedestinationstring() {\n    buffer()\n    // Ignore encoding the result, as we’ll first percent encode the url and\n    // encode manually after.\n    setData('ignoreEncode', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitresourcedestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume()\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitresourcetitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitmedia() {\n    let index = mediaStack.length - 1 // Skip current.\n    const media = mediaStack[index]\n    const id = media.referenceId || media.labelId\n    assert(id !== undefined, 'media should have `referenceId` or `labelId`')\n    assert(media.label !== undefined, 'media should have `label`')\n    const context =\n      media.destination === undefined\n        ? definitions[normalizeIdentifier(id)]\n        : media\n\n    tags = true\n\n    while (index--) {\n      if (mediaStack[index].image) {\n        tags = undefined\n        break\n      }\n    }\n\n    if (media.image) {\n      tag(\n        '<img src=\"' +\n          sanitizeUri(\n            context.destination,\n            settings.allowDangerousProtocol ? undefined : protocolSource\n          ) +\n          '\" alt=\"'\n      )\n      raw(media.label)\n      tag('\"')\n    } else {\n      tag(\n        '<a href=\"' +\n          sanitizeUri(\n            context.destination,\n            settings.allowDangerousProtocol ? undefined : protocolHref\n          ) +\n          '\"'\n      )\n    }\n\n    tag(context.title ? ' title=\"' + context.title + '\"' : '')\n\n    if (media.image) {\n      tag(' />')\n    } else {\n      tag('>')\n      raw(media.label)\n      tag('</a>')\n    }\n\n    mediaStack.pop()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterdefinition() {\n    buffer()\n    mediaStack.push({})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    resume()\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterdefinitiondestinationstring() {\n    buffer()\n    setData('ignoreEncode', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume()\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinition() {\n    const media = mediaStack[mediaStack.length - 1]\n    assert(media.labelId !== undefined, 'media should have `labelId`')\n    const id = normalizeIdentifier(media.labelId)\n\n    resume()\n\n    if (!hasOwnProperty.call(definitions, id)) {\n      definitions[id] = mediaStack[mediaStack.length - 1]\n    }\n\n    mediaStack.pop()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercontent() {\n    setData('slurpAllLineEndings', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    // Exit for further sequences.\n    if (getData('headingRank')) return\n    setData('headingRank', this.sliceSerialize(token).length)\n    lineEndingIfNeeded()\n    tag('<h' + getData('headingRank') + '>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentersetextheading() {\n    buffer()\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('slurpAllLineEndings', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheading() {\n    tag('</h' + getData('headingRank') + '>')\n    setData('headingRank')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    setData(\n      'headingRank',\n      this.sliceSerialize(token).charCodeAt(0) === codes.equalsTo ? 1 : 2\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    const value = resume()\n    lineEndingIfNeeded()\n    tag('<h' + getData('headingRank') + '>')\n    raw(value)\n    tag('</h' + getData('headingRank') + '>')\n    setData('slurpAllLineEndings')\n    setData('headingRank')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdata(token) {\n    raw(encode(this.sliceSerialize(token)))\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlineending(token) {\n    if (getData('slurpAllLineEndings')) {\n      return\n    }\n\n    if (getData('slurpOneLineEnding')) {\n      setData('slurpOneLineEnding')\n      return\n    }\n\n    if (getData('inCodeText')) {\n      raw(' ')\n      return\n    }\n\n    raw(encode(this.sliceSerialize(token)))\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeflowvalue(token) {\n    raw(encode(this.sliceSerialize(token)))\n    setData('flowCodeSeenData', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexithardbreak() {\n    tag('<br />')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterhtmlflow() {\n    lineEndingIfNeeded()\n    onenterhtml()\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexithtml() {\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterhtml() {\n    if (settings.allowDangerousHtml) {\n      setData('ignoreEncode', true)\n    }\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenteremphasis() {\n    tag('<em>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterstrong() {\n    tag('<strong>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onentercodetext() {\n    setData('inCodeText', true)\n    tag('<code>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitcodetext() {\n    setData('inCodeText')\n    tag('</code>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitemphasis() {\n    tag('</em>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitstrong() {\n    tag('</strong>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitthematicbreak() {\n    lineEndingIfNeeded()\n    tag('<hr />')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @param {Token} token\n   * @returns {undefined}\n   */\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const value = this.sliceSerialize(token)\n    const decoded = getData('characterReferenceType')\n      ? decodeNumericCharacterReference(\n          value,\n          getData('characterReferenceType') ===\n            types.characterReferenceMarkerNumeric\n            ? constants.numericBaseDecimal\n            : constants.numericBaseHexadecimal\n        )\n      : decodeNamedCharacterReference(value)\n\n    // `decodeNamedCharacterReference` can return `false` for invalid named\n    // character references,\n    // but everything we’ve tokenized is valid.\n    raw(encode(/** @type {string} */ (decoded)))\n    setData('characterReferenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    const uri = this.sliceSerialize(token)\n    tag(\n      '<a href=\"' +\n        sanitizeUri(\n          uri,\n          settings.allowDangerousProtocol ? undefined : protocolHref\n        ) +\n        '\">'\n    )\n    raw(encode(uri))\n    tag('</a>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    const uri = this.sliceSerialize(token)\n    tag('<a href=\"' + sanitizeUri('mailto:' + uri) + '\">')\n    raw(encode(uri))\n    tag('</a>')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}