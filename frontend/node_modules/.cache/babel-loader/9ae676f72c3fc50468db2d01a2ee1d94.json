{"ast":null,"code":"/**\n * @import {\n *   Code,\n *   Construct,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\nimport { ok as assert } from 'devlop';\nimport { asciiAlphanumeric, asciiAlpha, markdownLineEndingOrSpace, markdownLineEnding, markdownSpace } from 'micromark-util-character';\nimport { htmlBlockNames, htmlRawNames } from 'micromark-util-html-tag-name';\nimport { codes, constants, types } from 'micromark-util-symbol';\nimport { blankLine } from './blank-line.js';\n/** @type {Construct} */\n\nexport const htmlFlow = {\n  concrete: true,\n  name: 'htmlFlow',\n  resolveTo: resolveToHtmlFlow,\n  tokenize: tokenizeHtmlFlow\n};\n/** @type {Construct} */\n\nconst blankLineBefore = {\n  partial: true,\n  tokenize: tokenizeBlankLineBefore\n};\nconst nonLazyContinuationStart = {\n  partial: true,\n  tokenize: tokenizeNonLazyContinuationStart\n};\n/** @type {Resolver} */\n\nfunction resolveToHtmlFlow(events) {\n  let index = events.length;\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === types.htmlFlow) {\n      break;\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start; // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start; // Remove the line prefix.\n\n    events.splice(index - 2, 2);\n  }\n\n  return events;\n}\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this;\n  /** @type {number} */\n\n  let marker;\n  /** @type {boolean} */\n\n  let closingTag;\n  /** @type {string} */\n\n  let buffer;\n  /** @type {number} */\n\n  let index;\n  /** @type {Code} */\n\n  let markerB;\n  return start;\n  /**\n   * Start of HTML (flow).\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    return before(code);\n  }\n  /**\n   * At `<`, after optional whitespace.\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function before(code) {\n    assert(code === codes.lessThan, 'expected `<`');\n    effects.enter(types.htmlFlow);\n    effects.enter(types.htmlFlowData);\n    effects.consume(code);\n    return open;\n  }\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | <x />\n   *      ^\n   * > | <!doctype>\n   *      ^\n   * > | <!--xxx-->\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code);\n      closingTag = true;\n      return tagCloseStart;\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      marker = constants.htmlInstruction; // To do:\n      // tokenizer.concrete = true\n      // To do: use `markdown-rs` style interrupt.\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside;\n    } // ASCII alphabetical.\n\n\n    if (asciiAlpha(code)) {\n      assert(code !== null); // Always the case.\n\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *       ^\n   * > | <!--xxx-->\n   *       ^\n   * > | <![CDATA[>&<]]>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      marker = constants.htmlComment;\n      return commentOpenInside;\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      marker = constants.htmlCdata;\n      index = 0;\n      return cdataOpenInside;\n    } // ASCII alphabetical.\n\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      marker = constants.htmlDeclaration; // // Do not form containers.\n      // tokenizer.concrete = true\n\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `<!-`, inside a comment, at another `-`.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code); // // Do not form containers.\n      // tokenizer.concrete = true\n\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `<![`, inside CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *        ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString;\n\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code);\n\n      if (index === value.length) {\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok : continuation;\n      }\n\n      return cdataOpenInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | </x>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      assert(code !== null); // Always the case.\n\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In tag name.\n   *\n   * ```markdown\n   * > | <ab>\n   *      ^^\n   * > | </ab>\n   *       ^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagName(code) {\n    if (code === codes.eof || code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      const slash = code === codes.slash;\n      const name = buffer.toLowerCase();\n\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = constants.htmlRaw; // // Do not form containers.\n        // tokenizer.concrete = true\n\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = constants.htmlBasic;\n\n        if (slash) {\n          effects.consume(code);\n          return basicSelfClosing;\n        } // // Do not form containers.\n        // tokenizer.concrete = true\n\n\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n\n      marker = constants.htmlComplete; // Do not support complete HTML when interrupting.\n\n      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code) : closingTag ? completeClosingTagAfter(code) : completeAttributeNameBefore(code);\n    } // ASCII alphanumerical and `-`.\n\n\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After closing slash of a basic tag name.\n   *\n   * ```markdown\n   * > | <div/>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code); // // Do not form containers.\n      // tokenizer.concrete = true\n\n      return self.interrupt ? ok : continuation;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After closing slash of a complete tag name.\n   *\n   * ```markdown\n   * > | <x/>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeClosingTagAfter;\n    }\n\n    return completeEnd(code);\n  }\n  /**\n   * At an attribute name.\n   *\n   * At first, this state is used after a complete tag name, after whitespace,\n   * where it expects optional attributes or the end of the tag.\n   * It is also reused after attributes, when expecting more optional\n   * attributes.\n   *\n   * ```markdown\n   * > | <a />\n   *        ^\n   * > | <a :b>\n   *        ^\n   * > | <a _b>\n   *        ^\n   * > | <a b>\n   *        ^\n   * > | <a >\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return completeEnd;\n    } // ASCII alphanumerical and `:` and `_`.\n\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameBefore;\n    }\n\n    return completeEnd(code);\n  }\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | <a :b>\n   *         ^\n   * > | <a _b>\n   *         ^\n   * > | <a b>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeName(code) {\n    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n\n    return completeAttributeNameAfter(code);\n  }\n  /**\n   * After attribute name, at an optional initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b>\n   *         ^\n   * > | <a b=c>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameAfter;\n    }\n\n    return completeAttributeNameBefore(code);\n  }\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * > | <a b=\"c\">\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      markerB = code;\n      return completeAttributeValueQuoted;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n\n    return completeAttributeValueUnquoted(code);\n  }\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *           ^\n   * > | <a b='c'>\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code);\n      markerB = null;\n      return completeAttributeValueQuotedAfter;\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return completeAttributeValueQuoted;\n  }\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.slash || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent || markdownLineEndingOrSpace(code)) {\n      return completeAttributeNameAfter(code);\n    }\n\n    effects.consume(code);\n    return completeAttributeValueUnquoted;\n  }\n  /**\n   * After double or single quoted attribute value, before whitespace or the\n   * end of the tag.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === codes.slash || code === codes.greaterThan || markdownSpace(code)) {\n      return completeAttributeNameBefore(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * In certain circumstances of a complete tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return completeAfter;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `>` in a complete tag.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return continuation(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAfter;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In continuation of any HTML kind.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuation(code) {\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code);\n      return continuationCommentInside;\n    }\n\n    if (code === codes.lessThan && marker === constants.htmlRaw) {\n      effects.consume(code);\n      return continuationRawTagOpen;\n    }\n\n    if (code === codes.greaterThan && marker === constants.htmlDeclaration) {\n      effects.consume(code);\n      return continuationClose;\n    }\n\n    if (code === codes.questionMark && marker === constants.htmlInstruction) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    if (code === codes.rightSquareBracket && marker === constants.htmlCdata) {\n      effects.consume(code);\n      return continuationCdataInside;\n    }\n\n    if (markdownLineEnding(code) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {\n      effects.exit(types.htmlFlowData);\n      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code);\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData);\n      return continuationStart(code);\n    }\n\n    effects.consume(code);\n    return continuation;\n  }\n  /**\n   * In continuation, at eol.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationStart(code) {\n    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code);\n  }\n  /**\n   * In continuation, at eol, before non-lazy content.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationStartNonLazy(code) {\n    assert(markdownLineEnding(code));\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return continuationBefore;\n  }\n  /**\n   * In continuation, before non-lazy content.\n   *\n   * ```markdown\n   *   | <x>\n   * > | asd\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationStart(code);\n    }\n\n    effects.enter(types.htmlFlowData);\n    return continuation(code);\n  }\n  /**\n   * In comment continuation, after one `-`, expecting another.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In raw continuation, after `<`, at `/`.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                            ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      buffer = '';\n      return continuationRawEndTag;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In raw continuation, after `</`, in a raw tag name.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                             ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationRawEndTag(code) {\n    if (code === codes.greaterThan) {\n      const name = buffer.toLowerCase();\n\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code);\n        return continuationClose;\n      }\n\n      return continuation(code);\n    }\n\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      assert(code !== null); // Always the case.\n\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return continuationRawEndTag;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In cdata continuation, after `]`, expecting `]>`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *                  ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationCdataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In declaration or instruction continuation, at `>`.\n   *\n   * ```markdown\n   * > | <!-->\n   *         ^\n   * > | <?>\n   *       ^\n   * > | <!q>\n   *        ^\n   * > | <!--ab-->\n   *             ^\n   * > | <![CDATA[>&<]]>\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return continuationClose;\n    } // More dashes.\n\n\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In closed continuation: everything we get until the eol/eof is part of it.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData);\n      return continuationAfter(code);\n    }\n\n    effects.consume(code);\n    return continuationClose;\n  }\n  /**\n   * Done.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationAfter(code) {\n    effects.exit(types.htmlFlow); // // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    // // No longer concrete.\n    // tokenizer.concrete = false\n\n    return ok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeNonLazyContinuationStart(effects, ok, nok) {\n  const self = this;\n  return start;\n  /**\n   * At eol, before continuation.\n   *\n   * ```markdown\n   * > | * ```js\n   *            ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /**\n   * A continuation.\n   *\n   * ```markdown\n   *   | * ```js\n   * > | b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeBlankLineBefore(effects, ok, nok) {\n  return start;\n  /**\n   * Before eol, expecting blank line.\n   *\n   * ```markdown\n   * > | <div>\n   *          ^\n   *   |\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending');\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return effects.attempt(blankLine, ok, nok);\n  }\n}","map":{"version":3,"names":["ok","assert","asciiAlphanumeric","asciiAlpha","markdownLineEndingOrSpace","markdownLineEnding","markdownSpace","htmlBlockNames","htmlRawNames","codes","constants","types","blankLine","htmlFlow","concrete","name","resolveTo","resolveToHtmlFlow","tokenize","tokenizeHtmlFlow","blankLineBefore","partial","tokenizeBlankLineBefore","nonLazyContinuationStart","tokenizeNonLazyContinuationStart","events","index","length","type","linePrefix","start","splice","effects","nok","self","marker","closingTag","buffer","markerB","code","before","lessThan","enter","htmlFlowData","consume","open","exclamationMark","declarationOpen","slash","tagCloseStart","questionMark","htmlInstruction","interrupt","continuationDeclarationInside","String","fromCharCode","tagName","dash","htmlComment","commentOpenInside","leftSquareBracket","htmlCdata","cdataOpenInside","htmlDeclaration","value","cdataOpeningString","charCodeAt","continuation","eof","greaterThan","toLowerCase","includes","htmlRaw","htmlBasic","basicSelfClosing","htmlComplete","parser","lazy","now","line","completeClosingTagAfter","completeAttributeNameBefore","completeEnd","colon","underscore","completeAttributeName","dot","completeAttributeNameAfter","equalsTo","completeAttributeValueBefore","graveAccent","quotationMark","apostrophe","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","rightSquareBracket","continuationCdataInside","exit","check","continuationAfter","continuationStart","continuationStartNonLazy","lineEnding","continuationBefore","continuationRawEndTag","htmlRawSizeMax","after","attempt"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark-core-commonmark/dev/lib/html-flow.js"],"sourcesContent":["/**\n * @import {\n *   Code,\n *   Construct,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {\n  asciiAlphanumeric,\n  asciiAlpha,\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {codes, constants, types} from 'micromark-util-symbol'\nimport {blankLine} from './blank-line.js'\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  concrete: true,\n  name: 'htmlFlow',\n  resolveTo: resolveToHtmlFlow,\n  tokenize: tokenizeHtmlFlow\n}\n\n/** @type {Construct} */\nconst blankLineBefore = {partial: true, tokenize: tokenizeBlankLineBefore}\nconst nonLazyContinuationStart = {\n  partial: true,\n  tokenize: tokenizeNonLazyContinuationStart\n}\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n\n  while (index--) {\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === types.htmlFlow\n    ) {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start\n    // Remove the line prefix.\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n  let marker\n  /** @type {boolean} */\n  let closingTag\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {Code} */\n  let markerB\n\n  return start\n\n  /**\n   * Start of HTML (flow).\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * At `<`, after optional whitespace.\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlFlow)\n    effects.enter(types.htmlFlowData)\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | <x />\n   *      ^\n   * > | <!doctype>\n   *      ^\n   * > | <!--xxx-->\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      closingTag = true\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      marker = constants.htmlInstruction\n      // To do:\n      // tokenizer.concrete = true\n      // To do: use `markdown-rs` style interrupt.\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      assert(code !== null) // Always the case.\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *       ^\n   * > | <!--xxx-->\n   *       ^\n   * > | <![CDATA[>&<]]>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      marker = constants.htmlComment\n      return commentOpenInside\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      marker = constants.htmlCdata\n      index = 0\n      return cdataOpenInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      marker = constants.htmlDeclaration\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<!-`, inside a comment, at another `-`.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<![`, inside CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *        ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString\n\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n\n      if (index === value.length) {\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok : continuation\n      }\n\n      return cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | </x>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      assert(code !== null) // Always the case.\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In tag name.\n   *\n   * ```markdown\n   * > | <ab>\n   *      ^^\n   * > | </ab>\n   *       ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagName(code) {\n    if (\n      code === codes.eof ||\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      const slash = code === codes.slash\n      const name = buffer.toLowerCase()\n\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = constants.htmlRaw\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = constants.htmlBasic\n\n        if (slash) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      marker = constants.htmlComplete\n      // Do not support complete HTML when interrupting.\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : closingTag\n          ? completeClosingTagAfter(code)\n          : completeAttributeNameBefore(code)\n    }\n\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a basic tag name.\n   *\n   * ```markdown\n   * > | <div/>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a complete tag name.\n   *\n   * ```markdown\n   * > | <x/>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n\n  /**\n   * At an attribute name.\n   *\n   * At first, this state is used after a complete tag name, after whitespace,\n   * where it expects optional attributes or the end of the tag.\n   * It is also reused after attributes, when expecting more optional\n   * attributes.\n   *\n   * ```markdown\n   * > | <a />\n   *        ^\n   * > | <a :b>\n   *        ^\n   * > | <a _b>\n   *        ^\n   * > | <a b>\n   *        ^\n   * > | <a >\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    // ASCII alphanumerical and `:` and `_`.\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | <a :b>\n   *         ^\n   * > | <a _b>\n   *         ^\n   * > | <a b>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeName(code) {\n    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, at an optional initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b>\n   *         ^\n   * > | <a b=c>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * > | <a b=\"c\">\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      markerB = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    return completeAttributeValueUnquoted(code)\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *           ^\n   * > | <a b='c'>\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code)\n      markerB = null\n      return completeAttributeValueQuotedAfter\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.slash ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the\n   * end of the tag.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownSpace(code)\n    ) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a complete tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `>` in a complete tag.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return continuation(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In continuation of any HTML kind.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuation(code) {\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === codes.lessThan && marker === constants.htmlRaw) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === codes.greaterThan && marker === constants.htmlDeclaration) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === codes.questionMark && marker === constants.htmlInstruction) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === codes.rightSquareBracket && marker === constants.htmlCdata) {\n      effects.consume(code)\n      return continuationCdataInside\n    }\n\n    if (\n      markdownLineEnding(code) &&\n      (marker === constants.htmlBasic || marker === constants.htmlComplete)\n    ) {\n      effects.exit(types.htmlFlowData)\n      return effects.check(\n        blankLineBefore,\n        continuationAfter,\n        continuationStart\n      )(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData)\n      return continuationStart(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n\n  /**\n   * In continuation, at eol.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStart(code) {\n    return effects.check(\n      nonLazyContinuationStart,\n      continuationStartNonLazy,\n      continuationAfter\n    )(code)\n  }\n\n  /**\n   * In continuation, at eol, before non-lazy content.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStartNonLazy(code) {\n    assert(markdownLineEnding(code))\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return continuationBefore\n  }\n\n  /**\n   * In continuation, before non-lazy content.\n   *\n   * ```markdown\n   *   | <x>\n   * > | asd\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationStart(code)\n    }\n\n    effects.enter(types.htmlFlowData)\n    return continuation(code)\n  }\n\n  /**\n   * In comment continuation, after one `-`, expecting another.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `<`, at `/`.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `</`, in a raw tag name.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                             ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawEndTag(code) {\n    if (code === codes.greaterThan) {\n      const name = buffer.toLowerCase()\n\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code)\n        return continuationClose\n      }\n\n      return continuation(code)\n    }\n\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      assert(code !== null) // Always the case.\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In cdata continuation, after `]`, expecting `]>`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *                  ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCdataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In declaration or instruction continuation, at `>`.\n   *\n   * ```markdown\n   * > | <!-->\n   *         ^\n   * > | <?>\n   *       ^\n   * > | <!q>\n   *        ^\n   * > | <!--ab-->\n   *             ^\n   * > | <![CDATA[>&<]]>\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    // More dashes.\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In closed continuation: everything we get until the eol/eof is part of it.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData)\n      return continuationAfter(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n\n  /**\n   * Done.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationAfter(code) {\n    effects.exit(types.htmlFlow)\n    // // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    // // No longer concrete.\n    // tokenizer.concrete = false\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuationStart(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * At eol, before continuation.\n   *\n   * ```markdown\n   * > | * ```js\n   *            ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * A continuation.\n   *\n   * ```markdown\n   *   | * ```js\n   * > | b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLineBefore(effects, ok, nok) {\n  return start\n\n  /**\n   * Before eol, expecting blank line.\n   *\n   * ```markdown\n   * > | <div>\n   *          ^\n   *   |\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}