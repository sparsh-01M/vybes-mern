{"ast":null,"code":"/**\n * @import {\n *   Break,\n *   Blockquote,\n *   Code,\n *   Definition,\n *   Emphasis,\n *   Heading,\n *   Html,\n *   Image,\n *   InlineCode,\n *   Link,\n *   ListItem,\n *   List,\n *   Nodes,\n *   Paragraph,\n *   PhrasingContent,\n *   ReferenceType,\n *   Root,\n *   Strong,\n *   Text,\n *   ThematicBreak\n * } from 'mdast'\n * @import {\n *   Encoding,\n *   Event,\n *   Token,\n *   Value\n * } from 'micromark-util-types'\n * @import {Point} from 'unist'\n * @import {\n *   CompileContext,\n *   CompileData,\n *   Config,\n *   Extension,\n *   Handle,\n *   OnEnterError,\n *   Options\n * } from './types.js'\n */\nimport { ok as assert } from 'devlop';\nimport { toString } from 'mdast-util-to-string';\nimport { parse, postprocess, preprocess } from 'micromark';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { decodeString } from 'micromark-util-decode-string';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { codes, constants, types } from 'micromark-util-symbol';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { stringifyPosition } from 'unist-util-stringify-position';\nconst own = {}.hasOwnProperty;\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */\n\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n}\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\n\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      characterReference: onexitcharacterreference,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  };\n  configure(config, (options || {}).mdastExtensions || []);\n  /** @type {CompileData} */\n\n  const data = {};\n  return compile;\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    };\n    /** @type {Array<number>} */\n\n    const listStack = [];\n    let index = -1;\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === types.listOrdered || events[index][1].type === types.listUnordered) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          const tail = listStack.pop();\n          assert(typeof tail === 'number', 'expected list ot be open');\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n\n    index = -1;\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]];\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    } // Handle tokens still being open.\n\n\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1];\n      const handler = tail[1] || defaultOnError;\n      handler.call(context, undefined, tail[0]);\n    } // Figure out `root` position.\n\n\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    }; // Call transforms.\n\n    index = -1;\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n\n    return tree;\n  }\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n\n  function prepareList(events, start, length) {\n    let index = start - 1;\n    let containerBalance = -1;\n    let listSpread = false;\n    /** @type {Token | undefined} */\n\n    let listItem;\n    /** @type {number | undefined} */\n\n    let lineIndex;\n    /** @type {number | undefined} */\n\n    let firstBlankLineIndex;\n    /** @type {boolean | undefined} */\n\n    let atMarker;\n\n    while (++index <= length) {\n      const event = events[index];\n\n      switch (event[1].type) {\n        case types.listUnordered:\n        case types.listOrdered:\n        case types.blockQuote:\n          {\n            if (event[0] === 'enter') {\n              containerBalance++;\n            } else {\n              containerBalance--;\n            }\n\n            atMarker = undefined;\n            break;\n          }\n\n        case types.lineEndingBlank:\n          {\n            if (event[0] === 'enter') {\n              if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                firstBlankLineIndex = index;\n              }\n\n              atMarker = undefined;\n            }\n\n            break;\n          }\n\n        case types.linePrefix:\n        case types.listItemValue:\n        case types.listItemMarker:\n        case types.listItemPrefix:\n        case types.listItemPrefixWhitespace:\n          {\n            // Empty.\n            break;\n          }\n\n        default:\n          {\n            atMarker = undefined;\n          }\n      }\n\n      if (!containerBalance && event[0] === 'enter' && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === 'exit' && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {\n        if (listItem) {\n          let tailIndex = index;\n          lineIndex = undefined;\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex];\n\n            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {\n              if (tailEvent[0] === 'exit') continue;\n\n              if (lineIndex) {\n                events[lineIndex][1].type = types.lineEndingBlank;\n                listSpread = true;\n              }\n\n              tailEvent[1].type = types.lineEnding;\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {// Empty\n            } else {\n              break;\n            }\n          }\n\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            listItem._spread = true;\n          } // Fix position.\n\n\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        } // Create a new list item.\n\n\n        if (event[1].type === types.listItemPrefix) {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          };\n          listItem = item;\n          events.splice(index, 0, ['enter', item, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    }\n\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n\n\n  function opener(create, and) {\n    return open;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n  /**\n   * @type {CompileContext['buffer']}\n   */\n\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n  /**\n   * @type {CompileContext['enter']}\n   */\n\n\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1];\n    assert(parent, 'expected `parent`');\n    assert('children' in parent, 'expected `parent`');\n    /** @type {Array<Nodes>} */\n\n    const siblings = parent.children;\n    siblings.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler || undefined]);\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    };\n  }\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n\n\n  function closer(and) {\n    return close;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n  /**\n   * @type {CompileContext['exit']}\n   */\n\n\n  function exit(token, onExitError) {\n    const node = this.stack.pop();\n    assert(node, 'expected `node`');\n    const open = this.tokenStack.pop();\n\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): it’s not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        const handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n\n    assert(node.type !== 'fragment', 'unexpected fragment `exit`ed');\n    assert(node.position, 'expected `position` to be defined');\n    node.position.end = point(token.end);\n  }\n  /**\n   * @type {CompileContext['resume']}\n   */\n\n\n  function resume() {\n    return toString(this.stack.pop());\n  } //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2];\n      assert(ancestor, 'expected nodes on stack');\n      assert(ancestor.type === 'list', 'expected list on stack');\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), constants.numericBaseDecimal);\n      this.data.expectingFirstListItemValue = undefined;\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'code', 'expected code on stack');\n    node.lang = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfencemeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'code', 'expected code on stack');\n    node.meta = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return;\n    this.buffer();\n    this.data.flowCodeInside = true;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefenced() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'code', 'expected code on stack');\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    this.data.flowCodeInside = undefined;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodeindented() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'code', 'expected code on stack');\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'definition', 'expected definition on stack');\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitiontitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'definition', 'expected definition on stack');\n    node.title = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'definition', 'expected definition on stack');\n    node.url = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'heading', 'expected heading on stack');\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length;\n      assert(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, 'expected `depth` between `1` and `6`');\n      node.depth = depth;\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'heading', 'expected heading on stack');\n    node.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert('children' in node, 'expected parent on stack');\n    /** @type {Array<Nodes>} */\n\n    const siblings = node.children;\n    let tail = siblings[siblings.length - 1];\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text();\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: we’ll add `end` later.\n        end: undefined\n      };\n      siblings.push(tail);\n    }\n\n    this.stack.push(tail);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdata(token) {\n    const tail = this.stack.pop();\n    assert(tail, 'expected a `node` to be on the stack');\n    assert('value' in tail, 'expected a `literal` to be on the stack');\n    assert(tail.position, 'expected `node` to have an open position');\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1];\n    assert(context, 'expected `node`'); // If we’re at a hard break, include the line ending in there.\n\n    if (this.data.atHardBreak) {\n      assert('children' in context, 'expected `parent`');\n      const tail = context.children[context.children.length - 1];\n      assert(tail.position, 'expected tail to have a starting position');\n      tail.position.end = point(token.end);\n      this.data.atHardBreak = undefined;\n      return;\n    }\n\n    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithtmlflow() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'html', 'expected html on stack');\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithtmltext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'html', 'expected html on stack');\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodetext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'inlineCode', 'expected inline code on stack');\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'link', 'expected link on stack'); // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference'; // @ts-expect-error: mutate.\n\n      node.referenceType = referenceType; // @ts-expect-error: mutate.\n\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier; // @ts-expect-error: mutate.\n\n      delete node.label;\n    }\n\n    this.data.referenceType = undefined;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image', 'expected image on stack'); // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference'; // @ts-expect-error: mutate.\n\n      node.referenceType = referenceType; // @ts-expect-error: mutate.\n\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier; // @ts-expect-error: mutate.\n\n      delete node.label;\n    }\n\n    this.data.referenceType = undefined;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token);\n    const ancestor = this.stack[this.stack.length - 2];\n    assert(ancestor, 'expected ancestor on stack');\n    assert(ancestor.type === 'image' || ancestor.type === 'link', 'expected image or link on stack'); // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n\n    ancestor.label = decodeString(string); // @ts-expect-error: same as above.\n\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1];\n    assert(fragment, 'expected node on stack');\n    assert(fragment.type === 'fragment', 'expected fragment on stack');\n    const value = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image' || node.type === 'link', 'expected image or link on stack'); // Assume a reference.\n\n    this.data.inReference = true;\n\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children;\n      node.children = children;\n    } else {\n      node.alt = value;\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image' || node.type === 'link', 'expected image or link on stack');\n    node.url = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresourcetitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image' || node.type === 'link', 'expected image or link on stack');\n    node.title = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresource() {\n    this.data.inReference = undefined;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed';\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitreferencestring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image' || node.type === 'link', 'expected image reference or link reference on stack'); // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n\n    node.label = label; // @ts-expect-error: same as above.\n\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    this.data.referenceType = 'full';\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcharacterreferencemarker(token) {\n    assert(token.type === 'characterReferenceMarkerNumeric' || token.type === 'characterReferenceMarkerHexadecimal');\n    this.data.characterReferenceType = token.type;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token);\n    const type = this.data.characterReferenceType;\n    /** @type {string} */\n\n    let value;\n\n    if (type) {\n      value = decodeNumericCharacterReference(data, type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal);\n      this.data.characterReferenceType = undefined;\n    } else {\n      const result = decodeNamedCharacterReference(data);\n      assert(result !== false, 'expected reference to decode');\n      value = result;\n    }\n\n    const tail = this.stack[this.stack.length - 1];\n    assert(tail, 'expected `node`');\n    assert('value' in tail, 'expected `node.value`');\n    tail.value += value;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcharacterreference(token) {\n    const tail = this.stack.pop();\n    assert(tail, 'expected `node`');\n    assert(tail.position, 'expected `node.position`');\n    tail.position.end = point(token.end);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'link', 'expected link on stack');\n    node.url = this.sliceSerialize(token);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'link', 'expected link on stack');\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n  /** @returns {Code} */\n\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n  /** @returns {InlineCode} */\n\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n  /** @returns {Definition} */\n\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n  /** @returns {Emphasis} */\n\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n  /** @returns {Heading} */\n\n\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    };\n  }\n  /** @returns {Break} */\n\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n  /** @returns {Html} */\n\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n  /** @returns {Image} */\n\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n  /** @returns {Link} */\n\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n  /** @returns {Paragraph} */\n\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n  /** @returns {Strong} */\n\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n  /** @returns {Text} */\n\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n  /** @returns {ThematicBreak} */\n\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\n\n\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  };\n}\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */\n\n\nfunction configure(combined, extensions) {\n  let index = -1;\n\n  while (++index < extensions.length) {\n    const value = extensions[index];\n\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */\n\n\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key;\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols':\n          {\n            const right = extension[key];\n\n            if (right) {\n              combined[key].push(...right);\n            }\n\n            break;\n          }\n\n        case 'transforms':\n          {\n            const right = extension[key];\n\n            if (right) {\n              combined[key].push(...right);\n            }\n\n            break;\n          }\n\n        case 'enter':\n        case 'exit':\n          {\n            const right = extension[key];\n\n            if (right) {\n              Object.assign(combined[key], right);\n            }\n\n            break;\n          }\n        // No default\n      }\n    }\n  }\n}\n/** @type {OnEnterError} */\n\n\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + stringifyPosition({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}","map":{"version":3,"names":["ok","assert","toString","parse","postprocess","preprocess","decodeNumericCharacterReference","decodeString","normalizeIdentifier","codes","constants","types","decodeNamedCharacterReference","stringifyPosition","own","hasOwnProperty","fromMarkdown","value","encoding","options","undefined","compiler","document","write","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","list","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcharacterreference","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","configure","mdastExtensions","compile","events","tree","type","children","context","stack","tokenStack","resume","listStack","index","length","push","tail","pop","prepareList","handler","call","Object","assign","sliceSerialize","defaultOnError","position","start","point","line","column","offset","end","containerBalance","listSpread","lineIndex","firstBlankLineIndex","atMarker","event","lineEndingBlank","linePrefix","listItemMarker","listItemPrefix","listItemPrefixWhitespace","tailIndex","tailEvent","blockQuotePrefix","blockQuotePrefixWhitespace","blockQuoteMarker","listItemIndent","_spread","splice","item","create","and","open","token","node","errorHandler","parent","siblings","close","onExitError","Error","expectingFirstListItemValue","ancestor","Number","parseInt","numericBaseDecimal","lang","meta","flowCodeInside","replace","identifier","toLowerCase","title","url","depth","setextHeadingSlurpLineEnding","codePointAt","equalsTo","text","atHardBreak","includes","inReference","referenceType","string","fragment","alt","characterReferenceType","numericBaseHexadecimal","result","ordered","spread","checked","d","combined","extensions","Array","isArray","extension","key","right","left"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/mdast-util-from-markdown/dev/lib/index.js"],"sourcesContent":["/**\n * @import {\n *   Break,\n *   Blockquote,\n *   Code,\n *   Definition,\n *   Emphasis,\n *   Heading,\n *   Html,\n *   Image,\n *   InlineCode,\n *   Link,\n *   ListItem,\n *   List,\n *   Nodes,\n *   Paragraph,\n *   PhrasingContent,\n *   ReferenceType,\n *   Root,\n *   Strong,\n *   Text,\n *   ThematicBreak\n * } from 'mdast'\n * @import {\n *   Encoding,\n *   Event,\n *   Token,\n *   Value\n * } from 'micromark-util-types'\n * @import {Point} from 'unist'\n * @import {\n *   CompileContext,\n *   CompileData,\n *   Config,\n *   Extension,\n *   Handle,\n *   OnEnterError,\n *   Options\n * } from './types.js'\n */\n\nimport {ok as assert} from 'devlop'\nimport {toString} from 'mdast-util-to-string'\nimport {parse, postprocess, preprocess} from 'micromark'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {codes, constants, types} from 'micromark-util-symbol'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding\n    encoding = undefined\n  }\n\n  return compiler(options)(\n    postprocess(\n      parse(options)\n        .document()\n        .write(preprocess()(value, encoding, true))\n    )\n  )\n}\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      characterReference: onexitcharacterreference,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {type: 'root', children: []}\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === types.listOrdered ||\n        events[index][1].type === types.listUnordered\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          assert(typeof tail === 'number', 'expected list ot be open')\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {sliceSerialize: events[index][2].sliceSerialize},\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0 ? events[0][1].start : {line: 1, column: 1, offset: 0}\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {line: 1, column: 1, offset: 0}\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n\n    while (++index <= length) {\n      const event = events[index]\n\n      switch (event[1].type) {\n        case types.listUnordered:\n        case types.listOrdered:\n        case types.blockQuote: {\n          if (event[0] === 'enter') {\n            containerBalance++\n          } else {\n            containerBalance--\n          }\n\n          atMarker = undefined\n\n          break\n        }\n\n        case types.lineEndingBlank: {\n          if (event[0] === 'enter') {\n            if (\n              listItem &&\n              !atMarker &&\n              !containerBalance &&\n              !firstBlankLineIndex\n            ) {\n              firstBlankLineIndex = index\n            }\n\n            atMarker = undefined\n          }\n\n          break\n        }\n\n        case types.linePrefix:\n        case types.listItemValue:\n        case types.listItemMarker:\n        case types.listItemPrefix:\n        case types.listItemPrefixWhitespace: {\n          // Empty.\n\n          break\n        }\n\n        default: {\n          atMarker = undefined\n        }\n      }\n\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === types.listItemPrefix) ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === types.listUnordered ||\n            event[1].type === types.listOrdered))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n\n            if (\n              tailEvent[1].type === types.lineEnding ||\n              tailEvent[1].type === types.lineEndingBlank\n            ) {\n              if (tailEvent[0] === 'exit') continue\n\n              if (lineIndex) {\n                events[lineIndex][1].type = types.lineEndingBlank\n                listSpread = true\n              }\n\n              tailEvent[1].type = types.lineEnding\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === types.linePrefix ||\n              tailEvent[1].type === types.blockQuotePrefix ||\n              tailEvent[1].type === types.blockQuotePrefixWhitespace ||\n              tailEvent[1].type === types.blockQuoteMarker ||\n              tailEvent[1].type === types.listItemIndent\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === types.listItemPrefix) {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          }\n          listItem = item\n          events.splice(index, 0, ['enter', item, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @type {CompileContext['buffer']}\n   */\n  function buffer() {\n    this.stack.push({type: 'fragment', children: []})\n  }\n\n  /**\n   * @type {CompileContext['enter']}\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    assert(parent, 'expected `parent`')\n    assert('children' in parent, 'expected `parent`')\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    siblings.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler || undefined])\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    }\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @type {CompileContext['exit']}\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    assert(node, 'expected `node`')\n    const open = this.tokenStack.pop()\n\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({start: token.start, end: token.end}) +\n          '): it’s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n\n    assert(node.type !== 'fragment', 'unexpected fragment `exit`ed')\n    assert(node.position, 'expected `position` to be defined')\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @type {CompileContext['resume']}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2]\n      assert(ancestor, 'expected nodes on stack')\n      assert(ancestor.type === 'list', 'expected list on stack')\n      ancestor.start = Number.parseInt(\n        this.sliceSerialize(token),\n        constants.numericBaseDecimal\n      )\n      this.data.expectingFirstListItemValue = undefined\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return\n    this.buffer()\n    this.data.flowCodeInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    this.data.flowCodeInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'heading', 'expected heading on stack')\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n\n      assert(\n        depth === 1 ||\n          depth === 2 ||\n          depth === 3 ||\n          depth === 4 ||\n          depth === 5 ||\n          depth === 6,\n        'expected `depth` between `1` and `6`'\n      )\n\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'heading', 'expected heading on stack')\n\n    node.depth =\n      this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert('children' in node, 'expected parent on stack')\n    /** @type {Array<Nodes>} */\n    const siblings = node.children\n\n    let tail = siblings[siblings.length - 1]\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: we’ll add `end` later.\n        end: undefined\n      }\n      siblings.push(tail)\n    }\n\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    assert(tail, 'expected a `node` to be on the stack')\n    assert('value' in tail, 'expected a `literal` to be on the stack')\n    assert(tail.position, 'expected `node` to have an open position')\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    assert(context, 'expected `node`')\n\n    // If we’re at a hard break, include the line ending in there.\n    if (this.data.atHardBreak) {\n      assert('children' in context, 'expected `parent`')\n      const tail = context.children[context.children.length - 1]\n      assert(tail.position, 'expected tail to have a starting position')\n      tail.position.end = point(token.end)\n      this.data.atHardBreak = undefined\n      return\n    }\n\n    if (\n      !this.data.setextHeadingSlurpLineEnding &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'html', 'expected html on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'html', 'expected html on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'inlineCode', 'expected inline code on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut'\n\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n\n    this.data.referenceType = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'image', 'expected image on stack')\n\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut'\n\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n\n    this.data.referenceType = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    assert(ancestor, 'expected ancestor on stack')\n    assert(\n      ancestor.type === 'image' || ancestor.type === 'link',\n      'expected image or link on stack'\n    )\n\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    assert(fragment, 'expected node on stack')\n    assert(fragment.type === 'fragment', 'expected fragment on stack')\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n\n    // Assume a reference.\n    this.data.inReference = true\n\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children\n\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    this.data.inReference = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed'\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image reference or link reference on stack'\n    )\n\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    this.data.referenceType = 'full'\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    assert(\n      token.type === 'characterReferenceMarkerNumeric' ||\n        token.type === 'characterReferenceMarkerHexadecimal'\n    )\n    this.data.characterReferenceType = token.type\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = this.data.characterReferenceType\n    /** @type {string} */\n    let value\n\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === types.characterReferenceMarkerNumeric\n          ? constants.numericBaseDecimal\n          : constants.numericBaseHexadecimal\n      )\n      this.data.characterReferenceType = undefined\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      assert(result !== false, 'expected reference to decode')\n      value = result\n    }\n\n    const tail = this.stack[this.stack.length - 1]\n    assert(tail, 'expected `node`')\n    assert('value' in tail, 'expected `node.value`')\n    tail.value += value\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreference(token) {\n    const tail = this.stack.pop()\n    assert(tail, 'expected `node`')\n    assert(tail.position, 'expected `node.position`')\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {type: 'blockquote', children: []}\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {type: 'code', lang: null, meta: null, value: ''}\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {type: 'inlineCode', value: ''}\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {type: 'emphasis', children: []}\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {type: 'break'}\n  }\n\n  /** @returns {Html} */\n  function html() {\n    return {type: 'html', value: ''}\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {type: 'image', title: null, url: '', alt: null}\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {type: 'link', title: null, url: '', children: []}\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {type: 'paragraph', children: []}\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {type: 'strong', children: []}\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {type: 'text', value: ''}\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {type: 'thematicBreak'}\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {line: d.line, column: d.column, offset: d.offset}\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n\n  while (++index < extensions.length) {\n    const value = extensions[index]\n\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols': {\n          const right = extension[key]\n          if (right) {\n            combined[key].push(...right)\n          }\n\n          break\n        }\n\n        case 'transforms': {\n          const right = extension[key]\n          if (right) {\n            combined[key].push(...right)\n          }\n\n          break\n        }\n\n        case 'enter':\n        case 'exit': {\n          const right = extension[key]\n          if (right) {\n            Object.assign(combined[key], right)\n          }\n\n          break\n        }\n        // No default\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({start: left.start, end: left.end}) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({start: right.start, end: right.end}) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({start: right.start, end: right.end}) +\n        ') is still open'\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}