{"ast":null,"code":"/**\n * @import {Node, Point, Position} from 'unist'\n * @import {Options as MessageOptions} from 'vfile-message'\n * @import {Compatible, Data, Map, Options, Value} from 'vfile'\n */\n\n/**\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */\nimport { VFileMessage } from 'vfile-message';\nimport { minpath } from '#minpath';\nimport { minproc } from '#minproc';\nimport { urlToPath, isUrl } from '#minurl';\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n */\n\nconst order =\n/** @type {const} */\n['history', 'path', 'basename', 'stem', 'extname', 'dirname'];\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Uint8Array` ‚Äî `{value: options}`\n   * *   `URL` ‚Äî `{path: options}`\n   * *   `VFile` ‚Äî shallow copies its data over to the new file\n   * *   `object` ‚Äî all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options;\n\n    if (!value) {\n      options = {};\n    } else if (isUrl(value)) {\n      options = {\n        path: value\n      };\n    } else if (typeof value === 'string' || isUint8Array(value)) {\n      options = {\n        value\n      };\n    } else {\n      options = value;\n    }\n    /* eslint-disable no-unused-expressions */\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    // Prevent calling `cwd` (which could be expensive) if it‚Äôs not needed;\n    // the empty string will be overridden in the next block.\n\n\n    this.cwd = 'cwd' in options ? '' : minproc.cwd();\n    /**\n     * Place to store custom info (default: `{}`).\n     *\n     * It‚Äôs OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n\n    this.data = {};\n    /**\n     * List of file paths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n\n    this.history = [];\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n\n    this.messages = [];\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n\n    this.value; // The below are non-standard, they are ‚Äúwell-known‚Äù.\n    // As in, used in several tools.\n\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n\n    this.map;\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n\n    this.result;\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n\n    this.stored;\n    /* eslint-enable no-unused-expressions */\n    // Set path related properties in the correct order.\n\n    let index = -1;\n\n    while (++index < order.length) {\n      const field = order[index]; // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n\n      if (field in options && options[field] !== undefined && options[field] !== null) {\n        // @ts-expect-error: TS doesn‚Äôt understand basic reality.\n        this[field] = field === 'history' ? [...options[field]] : options[field];\n      }\n    }\n    /** @type {string} */\n\n\n    let field; // Set non-path related properties.\n\n    for (field in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(field)) {\n        // @ts-expect-error: fine to set other things.\n        this[field] = options[field];\n      }\n    }\n  }\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   *\n   * @returns {string | undefined}\n   *   Basename.\n   */\n\n\n  get basename() {\n    return typeof this.path === 'string' ? minpath.basename(this.path) : undefined;\n  }\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   *\n   * @param {string} basename\n   *   Basename.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename');\n    assertPart(basename, 'basename');\n    this.path = minpath.join(this.dirname || '', basename);\n  }\n  /**\n   * Get the parent path (example: `'~'`).\n   *\n   * @returns {string | undefined}\n   *   Dirname.\n   */\n\n\n  get dirname() {\n    return typeof this.path === 'string' ? minpath.dirname(this.path) : undefined;\n  }\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if there‚Äôs no `path` yet.\n   *\n   * @param {string | undefined} dirname\n   *   Dirname.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname');\n    this.path = minpath.join(dirname || '', this.basename);\n  }\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   *\n   * @returns {string | undefined}\n   *   Extname.\n   */\n\n\n  get extname() {\n    return typeof this.path === 'string' ? minpath.extname(this.path) : undefined;\n  }\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there‚Äôs no `path` yet.\n   *\n   * @param {string | undefined} extname\n   *   Extname.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  set extname(extname) {\n    assertPart(extname, 'extname');\n    assertPath(this.dirname, 'extname');\n\n    if (extname) {\n      if (extname.codePointAt(0) !== 46\n      /* `.` */\n      ) {\n        throw new Error('`extname` must start with `.`');\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots');\n      }\n    }\n\n    this.path = minpath.join(this.dirname, this.stem + (extname || ''));\n  }\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   *   Path.\n   */\n\n\n  get path() {\n    return this.history[this.history.length - 1];\n  }\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {URL | string} path\n   *   Path.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path);\n    }\n\n    assertNonEmpty(path, 'path');\n\n    if (this.path !== path) {\n      this.history.push(path);\n    }\n  }\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * @returns {string | undefined}\n   *   Stem.\n   */\n\n\n  get stem() {\n    return typeof this.path === 'string' ? minpath.basename(this.path, this.extname) : undefined;\n  }\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   *\n   * @param {string} stem\n   *   Stem.\n   * @returns {undefined}\n   *   Nothing.\n   */\n\n\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem');\n    assertPart(stem, 'stem');\n    this.path = minpath.join(this.dirname || '', stem + (this.extname || ''));\n  } // Normal prototypal methods.\n\n  /**\n   * Create a fatal message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `true` (error; file not usable)\n   * and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > ü™¶ **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Never.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n\n\n  fail(causeOrReason, optionsOrParentOrPlace, origin) {\n    // @ts-expect-error: the overloads are fine.\n    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);\n    message.fatal = true;\n    throw message;\n  }\n  /**\n   * Create an info message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `undefined` (info; change\n   * likely not needed) and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > ü™¶ **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n\n\n  info(causeOrReason, optionsOrParentOrPlace, origin) {\n    // @ts-expect-error: the overloads are fine.\n    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);\n    message.fatal = undefined;\n    return message;\n  }\n  /**\n   * Create a message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `false` (warning; change may be\n   * needed) and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > ü™¶ **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n\n\n  message(causeOrReason, optionsOrParentOrPlace, origin) {\n    const message = new VFileMessage( // @ts-expect-error: the overloads are fine.\n    causeOrReason, optionsOrParentOrPlace, origin);\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name;\n      message.file = this.path;\n    }\n\n    message.fatal = false;\n    this.messages.push(message);\n    return message;\n  }\n  /**\n   * Serialize the file.\n   *\n   * > **Note**: which encodings are supported depends on the engine.\n   * > For info on Node.js, see:\n   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.\n   *\n   * @param {string | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when it‚Äôs a `Uint8Array`\n   *   (default: `'utf-8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n\n\n  toString(encoding) {\n    if (this.value === undefined) {\n      return '';\n    }\n\n    if (typeof this.value === 'string') {\n      return this.value;\n    }\n\n    const decoder = new TextDecoder(encoding || undefined);\n    return decoder.decode(this.value);\n  }\n\n}\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {undefined}\n *   Nothing.\n */\n\nfunction assertPart(part, name) {\n  if (part && part.includes(minpath.sep)) {\n    throw new Error('`' + name + '` cannot be a path: did not expect `' + minpath.sep + '`');\n  }\n}\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\n\n\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty');\n  }\n}\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\n\n\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too');\n  }\n}\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */\n\n\nfunction isUint8Array(value) {\n  return Boolean(value && typeof value === 'object' && 'byteLength' in value && 'byteOffset' in value);\n}","map":{"version":3,"names":["VFileMessage","minpath","minproc","urlToPath","isUrl","order","VFile","constructor","value","options","path","isUint8Array","cwd","data","history","messages","map","result","stored","index","length","field","undefined","includes","basename","assertNonEmpty","assertPart","join","dirname","assertPath","extname","codePointAt","Error","stem","push","fail","causeOrReason","optionsOrParentOrPlace","origin","message","fatal","info","name","file","toString","encoding","decoder","TextDecoder","decode","part","sep","Boolean"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/vfile/lib/index.js"],"sourcesContent":["/**\n * @import {Node, Point, Position} from 'unist'\n * @import {Options as MessageOptions} from 'vfile-message'\n * @import {Compatible, Data, Map, Options, Value} from 'vfile'\n */\n\n/**\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {VFileMessage} from 'vfile-message'\nimport {minpath} from '#minpath'\nimport {minproc} from '#minproc'\nimport {urlToPath, isUrl} from '#minurl'\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n */\nconst order = /** @type {const} */ ([\n  'history',\n  'path',\n  'basename',\n  'stem',\n  'extname',\n  'dirname'\n])\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Uint8Array` ‚Äî `{value: options}`\n   * *   `URL` ‚Äî `{path: options}`\n   * *   `VFile` ‚Äî shallow copies its data over to the new file\n   * *   `object` ‚Äî all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else if (typeof value === 'string' || isUint8Array(value)) {\n      options = {value}\n    } else {\n      options = value\n    }\n\n    /* eslint-disable no-unused-expressions */\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    // Prevent calling `cwd` (which could be expensive) if it‚Äôs not needed;\n    // the empty string will be overridden in the next block.\n    this.cwd = 'cwd' in options ? '' : minproc.cwd()\n\n    /**\n     * Place to store custom info (default: `{}`).\n     *\n     * It‚Äôs OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of file paths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are ‚Äúwell-known‚Äù.\n    // As in, used in several tools.\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n    this.map\n\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n    this.stored\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const field = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (\n        field in options &&\n        options[field] !== undefined &&\n        options[field] !== null\n      ) {\n        // @ts-expect-error: TS doesn‚Äôt understand basic reality.\n        this[field] = field === 'history' ? [...options[field]] : options[field]\n      }\n    }\n\n    /** @type {string} */\n    let field\n\n    // Set non-path related properties.\n    for (field in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(field)) {\n        // @ts-expect-error: fine to set other things.\n        this[field] = options[field]\n      }\n    }\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   *\n   * @returns {string | undefined}\n   *   Basename.\n   */\n  get basename() {\n    return typeof this.path === 'string'\n      ? minpath.basename(this.path)\n      : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   *\n   * @param {string} basename\n   *   Basename.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = minpath.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   *\n   * @returns {string | undefined}\n   *   Dirname.\n   */\n  get dirname() {\n    return typeof this.path === 'string'\n      ? minpath.dirname(this.path)\n      : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if there‚Äôs no `path` yet.\n   *\n   * @param {string | undefined} dirname\n   *   Dirname.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = minpath.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   *\n   * @returns {string | undefined}\n   *   Extname.\n   */\n  get extname() {\n    return typeof this.path === 'string'\n      ? minpath.extname(this.path)\n      : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there‚Äôs no `path` yet.\n   *\n   * @param {string | undefined} extname\n   *   Extname.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.codePointAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = minpath.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   *   Path.\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {URL | string} path\n   *   Path.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * @returns {string | undefined}\n   *   Stem.\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? minpath.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   *\n   * @param {string} stem\n   *   Stem.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = minpath.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  // Normal prototypal methods.\n  /**\n   * Create a fatal message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `true` (error; file not usable)\n   * and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > ü™¶ **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Never.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(causeOrReason, optionsOrParentOrPlace, origin) {\n    // @ts-expect-error: the overloads are fine.\n    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n\n  /**\n   * Create an info message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `undefined` (info; change\n   * likely not needed) and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > ü™¶ **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(causeOrReason, optionsOrParentOrPlace, origin) {\n    // @ts-expect-error: the overloads are fine.\n    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin)\n\n    message.fatal = undefined\n\n    return message\n  }\n\n  /**\n   * Create a message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `false` (warning; change may be\n   * needed) and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > ü™¶ **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(causeOrReason, optionsOrParentOrPlace, origin) {\n    const message = new VFileMessage(\n      // @ts-expect-error: the overloads are fine.\n      causeOrReason,\n      optionsOrParentOrPlace,\n      origin\n    )\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * > **Note**: which encodings are supported depends on the engine.\n   * > For info on Node.js, see:\n   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.\n   *\n   * @param {string | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when it‚Äôs a `Uint8Array`\n   *   (default: `'utf-8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    if (this.value === undefined) {\n      return ''\n    }\n\n    if (typeof this.value === 'string') {\n      return this.value\n    }\n\n    const decoder = new TextDecoder(encoding || undefined)\n    return decoder.decode(this.value)\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {undefined}\n *   Nothing.\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(minpath.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + minpath.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */\nfunction isUint8Array(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'byteLength' in value &&\n      'byteOffset' in value\n  )\n}\n"],"mappings":"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AD,CAAT,EAAiB;MACfA,IAAI,GAAGP,SAAS,CAACO,IAAD,CAAhB;IACD;;IAEDe,cAAc,CAACf,IAAD,EAAO,MAAP,CAAd;;IAEA,IAAI,KAAKA,IAAL,KAAcA,IAAlB,EAAwB;MACtB,KAAKI,OAAL,CAAaoB,IAAb,CAAkBxB,IAAlB;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;;;EACU,IAAJuB,IAAI,GAAG;IACT,OAAO,OAAO,KAAKvB,IAAZ,KAAqB,QAArB,GACHT,OAAO,CAACuB,QAAR,CAAiB,KAAKd,IAAtB,EAA4B,KAAKoB,OAAjC,CADG,GAEHR,SAFJ;EAGD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACU,IAAJW,IAAI,CAACA,IAAD,EAAO;IACbR,cAAc,CAACQ,IAAD,EAAO,MAAP,CAAd;IACAP,UAAU,CAACO,IAAD,EAAO,MAAP,CAAV;IACA,KAAKvB,IAAL,GAAYT,OAAO,CAAC0B,IAAR,CAAa,KAAKC,OAAL,IAAgB,EAA7B,EAAiCK,IAAI,IAAI,KAAKH,OAAL,IAAgB,EAApB,CAArC,CAAZ;EACD,CAhTgB,CAkTjB;;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEK,IAAI,CAACC,aAAD,EAAgBC,sBAAhB,EAAwCC,MAAxC,EAAgD;IAClD;IACA,MAAMC,OAAO,GAAG,KAAKA,OAAL,CAAaH,aAAb,EAA4BC,sBAA5B,EAAoDC,MAApD,CAAhB;IAEAC,OAAO,CAACC,KAAR,GAAgB,IAAhB;IAEA,MAAMD,OAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEE,IAAI,CAACL,aAAD,EAAgBC,sBAAhB,EAAwCC,MAAxC,EAAgD;IAClD;IACA,MAAMC,OAAO,GAAG,KAAKA,OAAL,CAAaH,aAAb,EAA4BC,sBAA5B,EAAoDC,MAApD,CAAhB;IAEAC,OAAO,CAACC,KAAR,GAAgBlB,SAAhB;IAEA,OAAOiB,OAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEA,OAAO,CAACH,aAAD,EAAgBC,sBAAhB,EAAwCC,MAAxC,EAAgD;IACrD,MAAMC,OAAO,GAAG,IAAIvC,YAAJ,EACd;IACAoC,aAFc,EAGdC,sBAHc,EAIdC,MAJc,CAAhB;;IAOA,IAAI,KAAK5B,IAAT,EAAe;MACb6B,OAAO,CAACG,IAAR,GAAe,KAAKhC,IAAL,GAAY,GAAZ,GAAkB6B,OAAO,CAACG,IAAzC;MACAH,OAAO,CAACI,IAAR,GAAe,KAAKjC,IAApB;IACD;;IAED6B,OAAO,CAACC,KAAR,GAAgB,KAAhB;IAEA,KAAKzB,QAAL,CAAcmB,IAAd,CAAmBK,OAAnB;IAEA,OAAOA,OAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEK,QAAQ,CAACC,QAAD,EAAW;IACjB,IAAI,KAAKrC,KAAL,KAAec,SAAnB,EAA8B;MAC5B,OAAO,EAAP;IACD;;IAED,IAAI,OAAO,KAAKd,KAAZ,KAAsB,QAA1B,EAAoC;MAClC,OAAO,KAAKA,KAAZ;IACD;;IAED,MAAMsC,OAAO,GAAG,IAAIC,WAAJ,CAAgBF,QAAQ,IAAIvB,SAA5B,CAAhB;IACA,OAAOwB,OAAO,CAACE,MAAR,CAAe,KAAKxC,KAApB,CAAP;EACD;;AAjiBgB;AAoiBnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASkB,UAAT,CAAoBuB,IAApB,EAA0BP,IAA1B,EAAgC;EAC9B,IAAIO,IAAI,IAAIA,IAAI,CAAC1B,QAAL,CAActB,OAAO,CAACiD,GAAtB,CAAZ,EAAwC;IACtC,MAAM,IAAIlB,KAAJ,CACJ,MAAMU,IAAN,GAAa,sCAAb,GAAsDzC,OAAO,CAACiD,GAA9D,GAAoE,GADhE,CAAN;EAGD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASzB,cAAT,CAAwBwB,IAAxB,EAA8BP,IAA9B,EAAoC;EAClC,IAAI,CAACO,IAAL,EAAW;IACT,MAAM,IAAIjB,KAAJ,CAAU,MAAMU,IAAN,GAAa,mBAAvB,CAAN;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASb,UAAT,CAAoBnB,IAApB,EAA0BgC,IAA1B,EAAgC;EAC9B,IAAI,CAAChC,IAAL,EAAW;IACT,MAAM,IAAIsB,KAAJ,CAAU,cAAcU,IAAd,GAAqB,iCAA/B,CAAN;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS/B,YAAT,CAAsBH,KAAtB,EAA6B;EAC3B,OAAO2C,OAAO,CACZ3C,KAAK,IACH,OAAOA,KAAP,KAAiB,QADnB,IAEE,gBAAgBA,KAFlB,IAGE,gBAAgBA,KAJN,CAAd;AAMD"},"metadata":{},"sourceType":"module"}