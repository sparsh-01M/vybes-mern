{"ast":null,"code":"/**\n * @import {Chunk, Code, Encoding, Value} from 'micromark-util-types'\n */\n\n/**\n * @callback Preprocessor\n *   Preprocess a value.\n * @param {Value} value\n *   Value.\n * @param {Encoding | null | undefined} [encoding]\n *   Encoding when `value` is a typed array (optional).\n * @param {boolean | null | undefined} [end=false]\n *   Whether this is the last chunk (default: `false`).\n * @returns {Array<Chunk>}\n *   Chunks.\n */\nimport { codes, constants } from 'micromark-util-symbol';\nconst search = /[\\0\\t\\n\\r]/g;\n/**\n * @returns {Preprocessor}\n *   Preprocess a value.\n */\n\nexport function preprocess() {\n  let column = 1;\n  let buffer = '';\n  /** @type {boolean | undefined} */\n\n  let start = true;\n  /** @type {boolean | undefined} */\n\n  let atCarriageReturn;\n  return preprocessor;\n  /** @type {Preprocessor} */\n  // eslint-disable-next-line complexity\n\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = [];\n    /** @type {RegExpMatchArray | null} */\n\n    let match;\n    /** @type {number} */\n\n    let next;\n    /** @type {number} */\n\n    let startPosition;\n    /** @type {number} */\n\n    let endPosition;\n    /** @type {Code} */\n\n    let code;\n    value = buffer + (typeof value === 'string' ? value.toString() : new TextDecoder(encoding || undefined).decode(value));\n    startPosition = 0;\n    buffer = '';\n\n    if (start) {\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\n      if (value.charCodeAt(0) === codes.byteOrderMarker) {\n        startPosition++;\n      }\n\n      start = undefined;\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition;\n      match = search.exec(value);\n      endPosition = match && match.index !== undefined ? match.index : value.length;\n      code = value.charCodeAt(endPosition);\n\n      if (!match) {\n        buffer = value.slice(startPosition);\n        break;\n      }\n\n      if (code === codes.lf && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(codes.carriageReturnLineFeed);\n        atCarriageReturn = undefined;\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(codes.carriageReturn);\n          atCarriageReturn = undefined;\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition));\n          column += endPosition - startPosition;\n        }\n\n        switch (code) {\n          case codes.nul:\n            {\n              chunks.push(codes.replacementCharacter);\n              column++;\n              break;\n            }\n\n          case codes.ht:\n            {\n              next = Math.ceil(column / constants.tabSize) * constants.tabSize;\n              chunks.push(codes.horizontalTab);\n\n              while (column++ < next) chunks.push(codes.virtualSpace);\n\n              break;\n            }\n\n          case codes.lf:\n            {\n              chunks.push(codes.lineFeed);\n              column = 1;\n              break;\n            }\n\n          default:\n            {\n              atCarriageReturn = true;\n              column = 1;\n            }\n        }\n      }\n\n      startPosition = endPosition + 1;\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(codes.carriageReturn);\n      if (buffer) chunks.push(buffer);\n      chunks.push(codes.eof);\n    }\n\n    return chunks;\n  }\n}","map":{"version":3,"names":["codes","constants","search","preprocess","column","buffer","start","atCarriageReturn","preprocessor","value","encoding","end","chunks","match","next","startPosition","endPosition","code","toString","TextDecoder","undefined","decode","charCodeAt","byteOrderMarker","length","lastIndex","exec","index","slice","lf","push","carriageReturnLineFeed","carriageReturn","nul","replacementCharacter","ht","Math","ceil","tabSize","horizontalTab","virtualSpace","lineFeed","eof"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/micromark/dev/lib/preprocess.js"],"sourcesContent":["/**\n * @import {Chunk, Code, Encoding, Value} from 'micromark-util-types'\n */\n\n/**\n * @callback Preprocessor\n *   Preprocess a value.\n * @param {Value} value\n *   Value.\n * @param {Encoding | null | undefined} [encoding]\n *   Encoding when `value` is a typed array (optional).\n * @param {boolean | null | undefined} [end=false]\n *   Whether this is the last chunk (default: `false`).\n * @returns {Array<Chunk>}\n *   Chunks.\n */\n\nimport {codes, constants} from 'micromark-util-symbol'\n\nconst search = /[\\0\\t\\n\\r]/g\n\n/**\n * @returns {Preprocessor}\n *   Preprocess a value.\n */\nexport function preprocess() {\n  let column = 1\n  let buffer = ''\n  /** @type {boolean | undefined} */\n  let start = true\n  /** @type {boolean | undefined} */\n  let atCarriageReturn\n\n  return preprocessor\n\n  /** @type {Preprocessor} */\n  // eslint-disable-next-line complexity\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = []\n    /** @type {RegExpMatchArray | null} */\n    let match\n    /** @type {number} */\n    let next\n    /** @type {number} */\n    let startPosition\n    /** @type {number} */\n    let endPosition\n    /** @type {Code} */\n    let code\n\n    value =\n      buffer +\n      (typeof value === 'string'\n        ? value.toString()\n        : new TextDecoder(encoding || undefined).decode(value))\n\n    startPosition = 0\n    buffer = ''\n\n    if (start) {\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\n      if (value.charCodeAt(0) === codes.byteOrderMarker) {\n        startPosition++\n      }\n\n      start = undefined\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition\n      match = search.exec(value)\n      endPosition =\n        match && match.index !== undefined ? match.index : value.length\n      code = value.charCodeAt(endPosition)\n\n      if (!match) {\n        buffer = value.slice(startPosition)\n        break\n      }\n\n      if (\n        code === codes.lf &&\n        startPosition === endPosition &&\n        atCarriageReturn\n      ) {\n        chunks.push(codes.carriageReturnLineFeed)\n        atCarriageReturn = undefined\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(codes.carriageReturn)\n          atCarriageReturn = undefined\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition))\n          column += endPosition - startPosition\n        }\n\n        switch (code) {\n          case codes.nul: {\n            chunks.push(codes.replacementCharacter)\n            column++\n\n            break\n          }\n\n          case codes.ht: {\n            next = Math.ceil(column / constants.tabSize) * constants.tabSize\n            chunks.push(codes.horizontalTab)\n            while (column++ < next) chunks.push(codes.virtualSpace)\n\n            break\n          }\n\n          case codes.lf: {\n            chunks.push(codes.lineFeed)\n            column = 1\n\n            break\n          }\n\n          default: {\n            atCarriageReturn = true\n            column = 1\n          }\n        }\n      }\n\n      startPosition = endPosition + 1\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(codes.carriageReturn)\n      if (buffer) chunks.push(buffer)\n      chunks.push(codes.eof)\n    }\n\n    return chunks\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}