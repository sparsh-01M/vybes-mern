{"ast":null,"code":"import { fillWildcards } from './utils/fill-wildcards.mjs';\nimport { removeNonTranslationalTransform } from './utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nlet isForced = false;\n\nfunction measureAllKeyframes() {\n  if (anyNeedsMeasurement) {\n    const resolversToMeasure = Array.from(toResolve).filter(resolver => resolver.needsMeasurement);\n    const elementsToMeasure = new Set(resolversToMeasure.map(resolver => resolver.element));\n    const transformsToRestore = new Map();\n    /**\n     * Write pass\n     * If we're measuring elements we want to remove bounding box-changing transforms.\n     */\n\n    elementsToMeasure.forEach(element => {\n      const removedTransforms = removeNonTranslationalTransform(element);\n      if (!removedTransforms.length) return;\n      transformsToRestore.set(element, removedTransforms);\n      element.render();\n    }); // Read\n\n    resolversToMeasure.forEach(resolver => resolver.measureInitialState()); // Write\n\n    elementsToMeasure.forEach(element => {\n      element.render();\n      const restore = transformsToRestore.get(element);\n\n      if (restore) {\n        restore.forEach(_ref => {\n          let [key, value] = _ref;\n          element.getValue(key)?.set(value);\n        });\n      }\n    }); // Read\n\n    resolversToMeasure.forEach(resolver => resolver.measureEndState()); // Write\n\n    resolversToMeasure.forEach(resolver => {\n      if (resolver.suspendedScrollY !== undefined) {\n        window.scrollTo(0, resolver.suspendedScrollY);\n      }\n    });\n  }\n\n  anyNeedsMeasurement = false;\n  isScheduled = false;\n  toResolve.forEach(resolver => resolver.complete(isForced));\n  toResolve.clear();\n}\n\nfunction readAllKeyframes() {\n  toResolve.forEach(resolver => {\n    resolver.readKeyframes();\n\n    if (resolver.needsMeasurement) {\n      anyNeedsMeasurement = true;\n    }\n  });\n}\n\nfunction flushKeyframeResolvers() {\n  isForced = true;\n  readAllKeyframes();\n  measureAllKeyframes();\n  isForced = false;\n}\n\nclass KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    let isAsync = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    /**\n     * Track whether this resolver has completed. Once complete, it never\n     * needs to attempt keyframe resolution again.\n     */\n    this.isComplete = false;\n    /**\n     * Track whether this resolver is async. If it is, it'll be added to the\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\n     * to trigger read/write thrashing don't need to be async.\n     */\n\n    this.isAsync = false;\n    /**\n     * Track whether this resolver needs to perform a measurement\n     * to resolve its keyframes.\n     */\n\n    this.needsMeasurement = false;\n    /**\n     * Track whether this resolver is currently scheduled to resolve\n     * to allow it to be cancelled and resumed externally.\n     */\n\n    this.isScheduled = false;\n    this.unresolvedKeyframes = [...unresolvedKeyframes];\n    this.onComplete = onComplete;\n    this.name = name;\n    this.motionValue = motionValue;\n    this.element = element;\n    this.isAsync = isAsync;\n  }\n\n  scheduleResolve() {\n    this.isScheduled = true;\n\n    if (this.isAsync) {\n      toResolve.add(this);\n\n      if (!isScheduled) {\n        isScheduled = true;\n        frame.read(readAllKeyframes);\n        frame.resolveKeyframes(measureAllKeyframes);\n      }\n    } else {\n      this.readKeyframes();\n      this.complete();\n    }\n  }\n\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      name,\n      element,\n      motionValue\n    } = this; // If initial keyframe is null we need to read it from the DOM\n\n    if (unresolvedKeyframes[0] === null) {\n      const currentValue = motionValue?.get(); // TODO: This doesn't work if the final keyframe is a wildcard\n\n      const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n      if (currentValue !== undefined) {\n        unresolvedKeyframes[0] = currentValue;\n      } else if (element && name) {\n        const valueAsRead = element.readValue(name, finalKeyframe);\n\n        if (valueAsRead !== undefined && valueAsRead !== null) {\n          unresolvedKeyframes[0] = valueAsRead;\n        }\n      }\n\n      if (unresolvedKeyframes[0] === undefined) {\n        unresolvedKeyframes[0] = finalKeyframe;\n      }\n\n      if (motionValue && currentValue === undefined) {\n        motionValue.set(unresolvedKeyframes[0]);\n      }\n    }\n\n    fillWildcards(unresolvedKeyframes);\n  }\n\n  setFinalKeyframe() {}\n\n  measureInitialState() {}\n\n  renderEndStyles() {}\n\n  measureEndState() {}\n\n  complete() {\n    let isForced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.isComplete = true;\n    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForced);\n    toResolve.delete(this);\n  }\n\n  cancel() {\n    if (!this.isComplete) {\n      this.isScheduled = false;\n      toResolve.delete(this);\n    }\n  }\n\n  resume() {\n    if (!this.isComplete) this.scheduleResolve();\n  }\n\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };","map":{"version":3,"names":["fillWildcards","removeNonTranslationalTransform","frame","toResolve","Set","isScheduled","anyNeedsMeasurement","isForced","measureAllKeyframes","resolversToMeasure","Array","from","filter","resolver","needsMeasurement","elementsToMeasure","map","element","transformsToRestore","Map","forEach","removedTransforms","length","set","render","measureInitialState","restore","get","key","value","getValue","measureEndState","suspendedScrollY","undefined","window","scrollTo","complete","clear","readAllKeyframes","readKeyframes","flushKeyframeResolvers","KeyframeResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","isAsync","isComplete","scheduleResolve","add","read","resolveKeyframes","currentValue","finalKeyframe","valueAsRead","readValue","setFinalKeyframe","renderEndStyles","delete","cancel","resume"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs"],"sourcesContent":["import { fillWildcards } from './utils/fill-wildcards.mjs';\nimport { removeNonTranslationalTransform } from './utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nlet isForced = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    element.getValue(key)?.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete(isForced));\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    isForced = true;\n    readAllKeyframes();\n    measureAllKeyframes();\n    isForced = false;\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */\n        this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */\n        this.isScheduled = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        // If initial keyframe is null we need to read it from the DOM\n        if (unresolvedKeyframes[0] === null) {\n            const currentValue = motionValue?.get();\n            // TODO: This doesn't work if the final keyframe is a wildcard\n            const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n            if (currentValue !== undefined) {\n                unresolvedKeyframes[0] = currentValue;\n            }\n            else if (element && name) {\n                const valueAsRead = element.readValue(name, finalKeyframe);\n                if (valueAsRead !== undefined && valueAsRead !== null) {\n                    unresolvedKeyframes[0] = valueAsRead;\n                }\n            }\n            if (unresolvedKeyframes[0] === undefined) {\n                unresolvedKeyframes[0] = finalKeyframe;\n            }\n            if (motionValue && currentValue === undefined) {\n                motionValue.set(unresolvedKeyframes[0]);\n            }\n        }\n        fillWildcards(unresolvedKeyframes);\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete(isForced = false) {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForced);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete)\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}