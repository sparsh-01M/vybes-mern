{"ast":null,"code":"// To do: remove `void`s\n// To do: remove `null` from output of our APIs, allow it as user APIs.\n\n/**\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\n *   Callback.\n *\n * @typedef {(...input: Array<any>) => any} Middleware\n *   Ware.\n *\n * @typedef Pipeline\n *   Pipeline.\n * @property {Run} run\n *   Run the pipeline.\n * @property {Use} use\n *   Add middleware.\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n *\n *   Calls `done` on completion with either an error or the output of the\n *   last middleware.\n *\n *   > ðŸ‘‰ **Note**: as the length of input defines whether async functions get a\n *   > `next` function,\n *   > itâ€™s recommended to keep `input` at one value normally.\n\n *\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n *   Pipeline.\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = [];\n  /** @type {Pipeline} */\n\n  const pipeline = {\n    run,\n    use\n  };\n  return pipeline;\n  /** @type {Run} */\n\n  function run() {\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n\n    let middlewareIndex = -1;\n    /** @type {Callback} */\n\n    const callback = values.pop();\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback);\n    }\n\n    next(null, ...values);\n    /**\n     * Run the next `fn`, or weâ€™re done.\n     *\n     * @param {Error | null | undefined} error\n     * @param {Array<any>} output\n     */\n\n    function next(error) {\n      const fn = fns[++middlewareIndex];\n      let index = -1;\n\n      if (error) {\n        callback(error);\n        return;\n      } // Copy non-nullish input into values.\n\n\n      for (var _len2 = arguments.length, output = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        output[_key2 - 1] = arguments[_key2];\n      }\n\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index];\n        }\n      } // Save the newly created `output` for the next call.\n\n\n      values = output; // Next or done.\n\n      if (fn) {\n        wrap(fn, next)(...output);\n      } else {\n        callback(null, ...output);\n      }\n    }\n  }\n  /** @type {Use} */\n\n\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError('Expected `middelware` to be a function, not ' + middelware);\n    }\n\n    fns.push(middelware);\n    return pipeline;\n  }\n}\n/**\n * Wrap `middleware` into a uniform interface.\n *\n * You can pass all input to the resulting function.\n * `callback` is then called with the output of `middleware`.\n *\n * If `middleware` accepts more arguments than the later given in input,\n * an extra `done` function is passed to it after that input,\n * which must be called by `middleware`.\n *\n * The first value in `input` is the main input value.\n * All other input values are the rest input values.\n * The values given to `callback` are the input values,\n * merged with every non-nullish output value.\n *\n * * if `middleware` throws an error,\n *   returns a promise that is rejected,\n *   or calls the given `done` function with an error,\n *   `callback` is called with that error\n * * if `middleware` returns a value or returns a promise that is resolved,\n *   that value is the main output value\n * * if `middleware` calls `done`,\n *   all non-nullish values except for the first one (the error) overwrite the\n *   output values\n *\n * @param {Middleware} middleware\n *   Function to wrap.\n * @param {Callback} callback\n *   Callback called with the output of `middleware`.\n * @returns {Run}\n *   Wrapped middleware.\n */\n\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called;\n  return wrapped;\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n\n  function wrapped() {\n    for (var _len3 = arguments.length, parameters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      parameters[_key3] = arguments[_key3];\n    }\n\n    const fnExpectsCallback = middleware.length > parameters.length;\n    /** @type {any} */\n\n    let result;\n\n    if (fnExpectsCallback) {\n      parameters.push(done);\n    }\n\n    try {\n      result = middleware.apply(this, parameters);\n    } catch (error) {\n      const exception =\n      /** @type {Error} */\n      error; // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n\n      if (fnExpectsCallback && called) {\n        throw exception;\n      }\n\n      return done(exception);\n    }\n\n    if (!fnExpectsCallback) {\n      if (result && result.then && typeof result.then === 'function') {\n        result.then(then, done);\n      } else if (result instanceof Error) {\n        done(result);\n      } else {\n        then(result);\n      }\n    }\n  }\n  /**\n   * Call `callback`, only once.\n   *\n   * @type {Callback}\n   */\n\n\n  function done(error) {\n    if (!called) {\n      called = true;\n\n      for (var _len4 = arguments.length, output = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        output[_key4 - 1] = arguments[_key4];\n      }\n\n      callback(error, ...output);\n    }\n  }\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n\n\n  function then(value) {\n    done(null, value);\n  }\n}","map":{"version":3,"names":["trough","fns","pipeline","run","use","values","middlewareIndex","callback","pop","TypeError","next","error","fn","index","output","length","undefined","wrap","middelware","push","middleware","called","wrapped","parameters","fnExpectsCallback","result","done","apply","exception","then","Error","value"],"sources":["/Users/sparshsinghal/Downloads/vybes-mern-main/frontend/node_modules/trough/lib/index.js"],"sourcesContent":["// To do: remove `void`s\n// To do: remove `null` from output of our APIs, allow it as user APIs.\n\n/**\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\n *   Callback.\n *\n * @typedef {(...input: Array<any>) => any} Middleware\n *   Ware.\n *\n * @typedef Pipeline\n *   Pipeline.\n * @property {Run} run\n *   Run the pipeline.\n * @property {Use} use\n *   Add middleware.\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n *\n *   Calls `done` on completion with either an error or the output of the\n *   last middleware.\n *\n *   > ðŸ‘‰ **Note**: as the length of input defines whether async functions get a\n *   > `next` function,\n *   > itâ€™s recommended to keep `input` at one value normally.\n\n *\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n *   Pipeline.\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or weâ€™re done.\n     *\n     * @param {Error | null | undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware` into a uniform interface.\n *\n * You can pass all input to the resulting function.\n * `callback` is then called with the output of `middleware`.\n *\n * If `middleware` accepts more arguments than the later given in input,\n * an extra `done` function is passed to it after that input,\n * which must be called by `middleware`.\n *\n * The first value in `input` is the main input value.\n * All other input values are the rest input values.\n * The values given to `callback` are the input values,\n * merged with every non-nullish output value.\n *\n * * if `middleware` throws an error,\n *   returns a promise that is rejected,\n *   or calls the given `done` function with an error,\n *   `callback` is called with that error\n * * if `middleware` returns a value or returns a promise that is resolved,\n *   that value is the main output value\n * * if `middleware` calls `done`,\n *   all non-nullish values except for the first one (the error) overwrite the\n *   output values\n *\n * @param {Middleware} middleware\n *   Function to wrap.\n * @param {Callback} callback\n *   Callback called with the output of `middleware`.\n * @returns {Run}\n *   Wrapped middleware.\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result && result.then && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   *\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}