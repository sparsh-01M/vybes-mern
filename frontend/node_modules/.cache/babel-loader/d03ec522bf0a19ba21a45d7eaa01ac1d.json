{"ast":null,"code":"import { getValueTransition, frame, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = function (name, value, target) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let element = arguments.length > 4 ? arguments[4] : undefined;\n  let isHandoff = arguments.length > 5 ? arguments[5] : undefined;\n  return onComplete => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n\n    let {\n      elapsed = 0\n    } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = {\n      keyframes: Array.isArray(target) ? target : [null, target],\n      ease: \"easeOut\",\n      velocity: value.getVelocity(),\n      ...valueTransition,\n      delay: -elapsed,\n      onUpdate: v => {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      },\n      name,\n      motionValue: value,\n      element: isHandoff ? undefined : element\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n\n    if (!isTransitionDefined(valueTransition)) {\n      Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n\n\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n\n    if (options.from !== undefined) {\n      options.keyframes[0] = options.from;\n    }\n\n    let shouldSkip = false;\n\n    if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n      options.duration = 0;\n\n      if (options.delay === 0) {\n        shouldSkip = true;\n      }\n    }\n\n    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {\n      shouldSkip = true;\n      options.duration = 0;\n      options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n\n\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n\n      if (finalKeyframe !== undefined) {\n        frame.update(() => {\n          options.onUpdate(finalKeyframe);\n          options.onComplete();\n        });\n        return;\n      }\n    }\n\n    return new AsyncMotionValueAnimation(options);\n  };\n};\n\nexport { animateMotionValue };","map":{"version":3,"names":["getValueTransition","frame","AsyncMotionValueAnimation","secondsToMilliseconds","MotionGlobalConfig","getFinalKeyframe","getDefaultTransition","isTransitionDefined","animateMotionValue","name","value","target","transition","element","isHandoff","onComplete","valueTransition","delay","elapsed","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","undefined","Object","assign","duration","repeatDelay","from","shouldSkip","type","instantAnimations","skipAnimations","allowFlatten","get","finalKeyframe","update"],"sources":["/Users/sparshsinghal/Downloads/Instagram-mern-stack-main/frontend/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { getValueTransition, frame, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (MotionGlobalConfig.instantAnimations ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            return;\n        }\n    }\n    return new AsyncMotionValueAnimation(options);\n};\n\nexport { animateMotionValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}